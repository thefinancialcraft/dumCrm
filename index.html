<!DOCTYPE html>
<html lang="en">

<head>
  <!-- FlatIcon CDN for SVG icons -->
  <link rel="stylesheet" href="https://cdn-uicons.flaticon.com/uicons-solid-rounded/css/uicons-solid-rounded.css">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Insurance CRM</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
      -webkit-font-smoothing: antialiased;
      background-color: white;
    }

    /* Simple login page styles */
    .login-page {
      min-height: 100vh;
      background-color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }

    .login-container {
      background: white;
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      width: 100%;
      max-width: 400px;
      border: 1px solid #e5e7eb;
    }

    .login-form {
      margin-top: 1.5rem;
    }

    .login-input {
      width: 100%;
      padding: 0.875rem 1rem;
      margin: 0.5rem 0;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      font-size: 1rem;
      transition: all 0.2s ease;
      background: white;
      box-sizing: border-box;
    }

    .login-input:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .login-btn {
      width: 100%;
      padding: 0.875rem;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-top: 1rem;
    }

    .login-btn:hover {
      background: #2563eb;
    }

    .login-btn:active {
      transform: translateY(1px);
    }

    .error-message {
      color: #dc2626;
      font-size: 0.875rem;
      margin-top: 0.5rem;
      text-align: center;
    }

    .success-message {
      color: #059669;
      font-size: 0.875rem;
      margin-top: 0.5rem;
      text-align: center;
    }

    .google-btn {
      width: 100%;
      padding: 0.875rem;
      background: white;
      color: #374151;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      margin: 0.75rem 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .google-btn:hover {
      border-color: #4285f4;
      box-shadow: 0 2px 8px rgba(66, 133, 244, 0.15);
      transform: translateY(-1px);
    }

    .google-btn:active {
      transform: translateY(0);
    }

    .google-icon {
      width: 20px;
      height: 20px;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%234285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="%2334A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="%23FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="%23EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>') no-repeat center;
      background-size: contain;
    }

    .divider {
      display: flex;
      align-items: center;
      margin: 1.5rem 0;
      color: #6b7280;
      font-size: 0.875rem;
    }

    .divider::before,
    .divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: #e5e7eb;
    }

    .divider span {
      padding: 0 1rem;
      background: white;
    }

    .shape:nth-child(1) {
      width: 80px;
      height: 80px;
      top: 10%;
      left: 10%;
      animation-delay: 0s;
    }

    .shape:nth-child(2) {
      width: 120px;
      height: 120px;
      top: 60%;
      right: 10%;
      animation-delay: 2s;
    }

    .shape:nth-child(3) {
      width: 60px;
      height: 60px;
      bottom: 20%;
      left: 20%;
      animation-delay: 4s;
    }

    @keyframes float {

      0%,
      100% {
        transform: translateY(0px) rotate(0deg);
      }

      50% {
        transform: translateY(-20px) rotate(180deg);
      }
    }

    /* Mobile optimizations */
    @media (max-width: 640px) {
      .login-overlay {
        padding: 0.5rem;
      }

      .login-container {
        padding: 1.5rem;
        border-radius: 1.5rem;
        margin: 1rem 0;
      }

      .login-input,
      .login-btn,
      .google-btn {
        padding: 0.875rem 1rem;
        font-size: 0.95rem;
      }

      .login-input:focus {
        transform: none;
      }

      .login-btn:hover,
      .google-btn:hover {
        transform: none;
      }
    }

    .user-info {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .user-info:hover {
      background: #f9fafb;
      transform: translateY(-1px);
    }

    .user-info:active {
      transform: translateY(0);
    }

    .user-avatar {
      width: 2rem;
      height: 2rem;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 0.875rem;
    }

    .tab-active {
      background: white;
      color: #1f2937;

    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      z-index: 50;
      animation: fadeIn 0.2s ease;
    }

    .modal.active {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-content {
      animation: slideUp 0.3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes slideUp {
      from {
        transform: translateY(20px);
        opacity: 0;
      }

      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .card {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.08);
    }

    .badge {
      font-size: 0.7rem;
      padding: 0.3rem 0.65rem;
      border-radius: 20px;
      font-weight: 600;
      letter-spacing: 0.3px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      transition: all 0.3s ease;
    }

    .btn-primary:hover {
      box-shadow: 0 8px 16px rgba(102, 126, 234, 0.4);
      transform: translateY(-2px);
    }

    .btn-call {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      transition: all 0.3s ease;
    }

    .btn-call:hover {
      box-shadow: 0 8px 16px rgba(16, 185, 129, 0.4);
      transform: translateY(-2px);
    }

    .btn-whatsapp {
      background: linear-gradient(135deg, #25D366 0%, #128C7E 100%);
      transition: all 0.3s ease;
    }

    .btn-whatsapp:hover {
      box-shadow: 0 8px 16px rgba(37, 211, 102, 0.4);
      transform: translateY(-2px);
    }

    .glass-effect {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    select {
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23667eea' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 0.5rem center;
      background-size: 1.2em;
      padding-right: 2.5rem;
    }

    select option {
      padding: 0.5rem;
    }

    /* Custom styling for dropdown */
    select::-ms-expand {
      display: none;
    }

    select option:hover {
      background-color: #f3f4f6;
    }

    /* Dropdown list height when opened */
    select:not([multiple]) {
      height: 2.5rem;
    }

    /* Style for option list when opened */
    select option {
      font-size: 0.875rem;
      line-height: 1.25rem;
    }

    .gradient-bg {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    .chip-filter {
      transition: all 0.3s ease;
      border: 2px solid transparent;
    }

    .chip-filter:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .chip-active {
      background: #3b82f6 !important;
      color: white !important;
      border-color: #3b82f6;
    }

    /* Mobile-specific modal improvements */
    @media (max-width: 640px) {
      .modal {
        padding: 0.5rem;
      }

      .modal-content {
        border-radius: 1rem;
        margin: 0.5rem;
        max-height: calc(100vh - 1rem);
      }

      /* Improve touch targets */
      select,
      input,
      button {
        min-height: 44px;
      }

      /* Better spacing for mobile */
      .modal .space-y-4>*+* {
        margin-top: 1rem;
      }

      /* Improve dropdown visibility */
      select:focus {
        z-index: 10;
        position: relative;
      }

      /* Better scrolling on mobile */
      .modal-content {
        -webkit-overflow-scrolling: touch;
      }

      /* Larger text for better readability */
      .modal h3 {
        font-size: 1.125rem;
      }

      /* Better button spacing */
      .modal button {
        min-width: 44px;
        min-height: 44px;
      }
    }

    /* Prevent zoom on input focus on iOS */
    @media screen and (-webkit-min-device-pixel-ratio: 0) {

      select,
      input,
      textarea {
        font-size: 16px;
      }
    }

    /* Horizontal scrollable filter chips */
    .overflow-x-auto {
      scrollbar-width: none;
      /* Firefox */
      -ms-overflow-style: none;
      /* Internet Explorer 10+ */
    }

    .overflow-x-auto::-webkit-scrollbar {
      display: none;
      /* WebKit */
    }

    .scrollbar-hide {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    .scrollbar-hide::-webkit-scrollbar {
      display: none;
    }

    /* Mobile-specific improvements */
    @media (max-width: 640px) {
      .card {
        margin-bottom: 0.75rem;
      }

      .modal-content {
        margin: 0.5rem;
        max-height: 95vh;
      }

      .btn-call,
      .btn-whatsapp,
      .btn-primary {
        min-height: 44px;
        /* Better touch targets */
      }

      .tab-active,
      .tab-inactive {
        font-size: 0.75rem;
        padding: 0.5rem 0.75rem;
      }

      .chip-filter,
      .callback-chip-filter {
        font-size: 0.75rem;
        padding: 0.375rem 0.75rem;
      }
    }

    /* Ensure proper touch targets on mobile */
    @media (max-width: 640px) {

      button,
      a,
      input,
      select,
      textarea {
        min-height: 44px;
      }

      .user-avatar {
        min-width: 44px;
        min-height: 44px;
      }

      /* Improve text readability on mobile */
      .card h3 {
        font-size: 0.875rem;
        line-height: 1.25rem;
      }

      .card p,
      .card span {
        font-size: 0.75rem;
      }

      /* Better spacing for mobile cards */
      .card>div {
        padding: 1rem;
      }

      /* Improve button spacing */
      .grid.grid-cols-1.gap-2>* {
        margin-bottom: 0.5rem;
      }
    }

    /* Tablet improvements */
    @media (min-width: 641px) and (max-width: 1024px) {
      .card>div {
        padding: 1.25rem;
      }

      .grid.grid-cols-1.sm\\:grid-cols-3 {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    /* Ensure chips don't shrink */
    .chip-filter {
      flex-shrink: 0;
      white-space: nowrap;
    }
  </style>
</head>

<body>

  <!-- Simple Login Page -->
  <div class="login-page">
    <div class="login-container">
      <div class="text-center mb-6">
        <div
          class="w-16 h-16 mx-auto mb-4 bg-blue-100 rounded-full flex items-center justify-center text-blue-600 text-2xl">
          üè•
        </div>
        <h1 class="text-2xl font-bold text-gray-900 mb-2">Insurance CRM</h1>
        <p class="text-gray-600">Sign in to your account</p>
      </div>

      <!-- Google Sign In Button
      <button onclick="handleGoogleLogin()" class="google-btn">
        <div class="google-icon"></div>
        Continue with Google
      </button> -->
      <!-- 
      <div class="divider">
        <span>or</span>
      </div> -->

      <form class="login-form" onsubmit="handleLogin(event)">
        <div class="mb-4">
          <label for="email" class="block text-sm font-medium text-gray-700 mb-2">Email</label>
          <input type="email" id="email" class="login-input" placeholder="Enter your email" required>
        </div>

        <div class="mb-6">
          <label for="password" class="block text-sm font-medium text-gray-700 mb-2">Password</label>
          <input type="password" id="password" class="login-input" placeholder="Enter your password" required>
        </div>

        <button type="submit" class="login-btn">Sign In</button>

        <div id="errorMessage" class="error-message hidden"></div>
        <div id="successMessage" class="success-message hidden"></div>
      </form>

      <div class="mt-6 text-center">
        <!-- <p class="text-sm text-gray-500">
          Demo: admin@example.com / password123
        </p> -->
        <p class="text-sm text-gray-500 mt-2">
          Don't have an account?
          <a href="#" onclick="toggleSignupForm()" class="text-blue-600 hover:text-blue-500 font-medium">Sign up</a>
        </p>
      </div>
    </div>

    <!-- Signup Form -->
    <div class="login-container hidden" id="signupContainer">
      <div class="text-center mb-6">
        <div
          class="w-16 h-16 mx-auto mb-4 bg-blue-100 rounded-full flex items-center justify-center text-blue-600 text-2xl">
          üè•
        </div>
        <h1 class="text-2xl font-bold text-gray-900 mb-2">Insurance CRM</h1>
        <p class="text-gray-600">Create your account</p>
      </div>

      <form class="login-form" onsubmit="handleSignup(event)">
        <div class="mb-4">
          <label for="signupName" class="block text-sm font-medium text-gray-700 mb-2">Full Name</label>
          <input type="text" id="signupName" class="login-input" placeholder="Enter your full name" required>
        </div>

        <div class="mb-4">
          <label for="signupEmail" class="block text-sm font-medium text-gray-700 mb-2">Email</label>
          <input type="email" id="signupEmail" class="login-input" placeholder="Enter your email" required>
        </div>

        <div class="mb-4">
          <label for="signupPassword" class="block text-sm font-medium text-gray-700 mb-2">Password</label>
          <input type="password" id="signupPassword" class="login-input" placeholder="Create a password" required
            minlength="6">
        </div>

        <div class="mb-6">
          <label for="confirmPassword" class="block text-sm font-medium text-gray-700 mb-2">Confirm Password</label>
          <input type="password" id="confirmPassword" class="login-input" placeholder="Confirm your password" required>
        </div>

        <button type="submit" class="login-btn">Create Account</button>

        <div id="signupErrorMessage" class="error-message hidden"></div>
        <div id="signupSuccessMessage" class="success-message hidden"></div>
      </form>

      <div class="mt-6 text-center">
        <p class="text-sm text-gray-500">
          Already have an account?
          <a href="#" onclick="toggleSignupForm()" class="text-blue-600 hover:text-blue-500 font-medium">Sign in</a>
        </p>
      </div>
    </div>
  </div>

  <!-- Main App Content (hidden initially) -->
  <div id="mainApp" class="hidden min-h-screen flex flex-col">
    <!-- Header -->
    <header class="bg-white shadow-sm sticky top-0 z-40 border-b border-gray-200">
      <div class="px-3 sm:px-4 py-3">
        <div class="flex items-center justify-between w-full">
          <!-- Left: Avatar -->
          <div class="flex items-center">
            <div class="w-10 h-10 rounded-full bg-gray-400 flex items-center justify-center text-white text-lg font-medium select-none" onclick="switchTab('settings');" id="userAvatar">D</div>
          </div>
          <!-- Center: Title and Subtitle -->
          <div class="flex flex-col items-center flex-1">
            <span class="text-base font-semibold text-gray-900 leading-tight" style="margin-bottom:-2px;">TFC Nexus</span>
            <span class="text-xs text-gray-500">Call Managment system</span>
          </div>
          <!-- Right: Logout Icon -->
          <div class="flex items-center">
            <button onclick="handleLogout()" title="Logout" class="p-2 rounded-full hover:bg-red-50 transition">
              <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="#ef4444" class="w-6 h-6">
                <path stroke-linecap="round" stroke-linejoin="round" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a2 2 0 01-2 2H7a2 2 0 01-2-2V7a2 2 0 012-2h4a2 2 0 012 2v1" />
              </svg>
            </button>
          </div>
        </div>
      </div>

      <!-- Navigation Tabs -->

      <!-- Filter Chips (shown only when Done tab is active) -->
      <div id="doneFilterChips" class="px-3 sm:px-4 pb-3 hidden">
        <div class="flex gap-2 overflow-x-auto scrollbar-hide">
          <button onclick="setDoneFilter('all')" id="chip-all"
            class="chip-filter chip-active px-2 sm:px-3 py-1.5 text-xs font-medium rounded-full bg-blue-100 text-blue-700 whitespace-nowrap">
            All
          </button>
          <button onclick="setDoneFilter('interested')" id="chip-interested"
            class="chip-filter px-2 sm:px-3 py-1.5 text-xs font-medium rounded-full bg-green-100 text-green-700 whitespace-nowrap">
            ‚úÖ Interested
          </button>
          <button onclick="setDoneFilter('not_interested')" id="chip-not_interested"
            class="chip-filter px-2 sm:px-3 py-1.5 text-xs font-medium rounded-full bg-red-100 text-red-700 whitespace-nowrap">
            ‚ùå Not Interested
          </button>
          <button onclick="setDoneFilter('wrong_number')" id="chip-wrong_number"
            class="chip-filter px-2 sm:px-3 py-1.5 text-xs font-medium rounded-full bg-gray-100 text-gray-700 whitespace-nowrap">
            üö´ Wrong Number
          </button>
          <button onclick="setDoneFilter('not_reachable')" id="chip-not_reachable"
            class="chip-filter px-2 sm:px-3 py-1.5 text-xs font-medium rounded-full bg-orange-100 text-orange-700 whitespace-nowrap">
            üìµ Not Reachable
          </button>
          <button onclick="setDoneFilter('already_renewed')" id="chip-already_renewed"
            class="chip-filter px-2 sm:px-3 py-1.5 text-xs font-medium rounded-full bg-blue-100 text-blue-700 whitespace-nowrap">
            ‚úîÔ∏è Renewed
          </button>
          <button onclick="setDoneFilter('will_think')" id="chip-will_think"
            class="chip-filter px-2 sm:px-3 py-1.5 text-xs font-medium rounded-full bg-purple-100 text-purple-700 whitespace-nowrap">
            ü§î Thinking
          </button>
        </div>
      </div>

      <!-- Filter Chips (shown only when Callback tab is active) -->
      <div id="callbackFilterChips" class="px-3 sm:px-4 pb-3 hidden">
        <div class="flex gap-2 overflow-x-auto scrollbar-hide">
          <button onclick="setCallbackFilter('all')" id="callback-chip-all"
            class="callback-chip-filter callback-chip-active px-2 sm:px-3 py-1.5 text-xs font-medium rounded-full bg-blue-100 text-blue-700 whitespace-nowrap">
            All
          </button>
          <button onclick="setCallbackFilter('upcoming')" id="callback-chip-upcoming"
            class="callback-chip-filter px-2 sm:px-3 py-1.5 text-xs font-medium rounded-full bg-green-100 text-green-700 whitespace-nowrap">
            ‚è∞ Upcoming
          </button>
          <button onclick="setCallbackFilter('overdue')" id="callback-chip-overdue"
            class="callback-chip-filter px-2 sm:px-3 py-1.5 text-xs font-medium rounded-full bg-red-100 text-red-700 whitespace-nowrap">
            ‚ö†Ô∏è Overdue
          </button>
        </div>
      </div>
    </header>

    <!-- Search Bar -->
    <div id="searchBar" class="px-3 sm:px-4 py-3 border-gray-200">
      <div class="relative">
        <input type="text" id="searchInput" placeholder="Search customers..."
          class="w-full pl-10 pr-4 py-2.5 bg-white border border-gray-200 rounded-lg text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
        <span class="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 text-sm">üîç</span>
      </div>
    </div>

    <!-- Settings Tab Content -->
    <div id="settingsContent" class="px-3 sm:px-5 py-4 sm:py-6 hidden">
      <div class="max-w-2xl mx-auto space-y-4 sm:space-y-5">
        <!-- Import Section -->
        <div
          class="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-3xl p-4 sm:p-6 border-2 border-blue-100 shadow-sm">
          <div class="flex flex-col sm:flex-row items-start gap-3 sm:gap-4">
            <div
              class="w-12 h-12 rounded-2xl bg-gradient-to-br from-blue-500 to-indigo-600 flex items-center justify-center text-2xl flex-shrink-0 mx-auto sm:mx-0">
              üì•
            </div>
            <div class="flex-1 w-full">
              <h3 class="text-base sm:text-lg font-bold text-gray-800 mb-2 text-center sm:text-left">Import Customer
                Data</h3>
              <p class="text-sm text-gray-600 mb-4 leading-relaxed text-center sm:text-left">Upload your CSV file with
                customer leads. Make sure
                to use the correct format by downloading our template first.</p>

              <div class="flex flex-col sm:flex-row gap-3">
                <button onclick="downloadSampleTemplate()"
                  class="flex-1 bg-white border-2 border-blue-300 text-blue-700 font-semibold py-3 px-4 sm:px-5 rounded-xl text-sm hover:bg-blue-50 hover:border-blue-400 transition-all shadow-sm">
                  üìÑ Download Template
                </button>

                <input type="file" id="csvFileInput" accept=".csv" class="hidden" onchange="handleFileUpload(event)">
                <button onclick="document.getElementById('csvFileInput').click()"
                  class="flex-1 bg-gradient-to-r from-blue-500 to-indigo-600 text-white font-semibold py-3 px-4 sm:px-5 rounded-xl text-sm hover:shadow-lg transition-all">
                  üì§ Upload CSV
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Export Section -->
        <div
          class="bg-gradient-to-r from-green-50 to-emerald-50 rounded-3xl p-4 sm:p-6 border-2 border-green-100 shadow-sm">
          <div class="flex flex-col sm:flex-row items-start gap-3 sm:gap-4">
            <div
              class="w-12 h-12 rounded-2xl bg-gradient-to-br from-green-500 to-emerald-600 flex items-center justify-center text-2xl flex-shrink-0 mx-auto sm:mx-0">
              üì§
            </div>
            <div class="flex-1 w-full">
              <h3 class="text-base sm:text-lg font-bold text-gray-800 mb-2 text-center sm:text-left">Export Complete
                Data</h3>
              <p class="text-sm text-gray-600 mb-4 leading-relaxed text-center sm:text-left">Download all customer leads
                with complete
                disposition history, notes, callbacks, and interaction timeline.</p>

              <button onclick="exportData()"
                class="w-full bg-gradient-to-r from-green-500 to-emerald-600 text-white font-semibold py-3 px-4 sm:px-5 rounded-xl text-sm hover:shadow-lg transition-all">
                üíæ Export to CSV
              </button>
            </div>
          </div>
        </div>

        <!-- Restore Backup Section -->
        <div
          class="bg-gradient-to-r from-orange-50 to-amber-50 rounded-3xl p-4 sm:p-6 border-2 border-orange-100 shadow-sm">
          <div class="flex flex-col sm:flex-row items-start gap-3 sm:gap-4">
            <div
              class="w-12 h-12 rounded-2xl bg-gradient-to-br from-orange-500 to-amber-600 flex items-center justify-center text-2xl flex-shrink-0 mx-auto sm:mx-0">
              ‚ö°
            </div>
            <div class="flex-1 w-full">
              <h3 class="text-base sm:text-lg font-bold text-gray-800 mb-2 text-center sm:text-left">Restore from Backup
              </h3>
              <p class="text-sm text-gray-600 mb-4 leading-relaxed text-center sm:text-left">Upload previously exported
                CSV file to restore all
                data including complete disposition history and notes.</p>

              <input type="file" id="backupFileInput" accept=".csv" class="hidden"
                onchange="handleBackupRestore(event)">
              <button onclick="document.getElementById('backupFileInput').click()"
                class="w-full bg-gradient-to-r from-orange-500 to-amber-600 text-white font-semibold py-3 px-4 sm:px-5 rounded-xl text-sm hover:shadow-lg transition-all">
                üì• Restore Backup
              </button>
            </div>
          </div>
        </div>

        <!-- Stats Section -->
        <div
          class="bg-gradient-to-r from-purple-50 to-pink-50 rounded-3xl p-4 sm:p-6 border-2 border-purple-100 shadow-sm">
          <div class="flex flex-col sm:flex-row items-start gap-3 sm:gap-4">
            <div
              class="w-12 h-12 rounded-2xl bg-gradient-to-br from-purple-500 to-pink-600 flex items-center justify-center text-2xl flex-shrink-0 mx-auto sm:mx-0">
              üìä
            </div>
            <div class="flex-1 w-full">
              <h3 class="text-base sm:text-lg font-bold text-gray-800 mb-3 text-center sm:text-left">System Statistics
              </h3>
              <div class="grid grid-cols-2 gap-3">
                <div class="bg-white rounded-xl p-3 sm:p-4">
                  <div class="text-xl sm:text-2xl font-bold text-purple-600" id="stat-total">0</div>
                  <div class="text-xs text-gray-500 mt-1">Total Leads</div>
                </div>
                <div class="bg-white rounded-xl p-3 sm:p-4">
                  <div class="text-xl sm:text-2xl font-bold text-green-600" id="stat-contacted">0</div>
                  <div class="text-xs text-gray-500 mt-1">Contacted</div>
                </div>
                <div class="bg-white rounded-xl p-3 sm:p-4">
                  <div class="text-xl sm:text-2xl font-bold text-orange-600" id="stat-pending">0</div>
                  <div class="text-xs text-gray-500 mt-1">Pending</div>
                </div>
                <div class="bg-white rounded-xl p-3 sm:p-4">
                  <div class="text-xl sm:text-2xl font-bold text-yellow-600" id="stat-callback">0</div>
                  <div class="text-xs text-gray-500 mt-1">Callbacks</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Account Section -->
        <div class="bg-gradient-to-r from-red-50 to-pink-50 rounded-3xl p-4 sm:p-6 border-2 border-red-100 shadow-sm">
          <div class="flex flex-col sm:flex-row items-start gap-3 sm:gap-4">
            <div
              class="w-12 h-12 rounded-2xl bg-gradient-to-br from-red-500 to-pink-600 flex items-center justify-center text-2xl flex-shrink-0 mx-auto sm:mx-0">
              üë§
            </div>
            <div class="flex-1 w-full">
              <h3 class="text-base sm:text-lg font-bold text-gray-800 mb-2 text-center sm:text-left">Account Management
              </h3>
              <p class="text-sm text-gray-600 mb-4 leading-relaxed text-center sm:text-left">Manage your account
                settings and sign out from the
                application.</p>

              <div class="flex flex-col sm:flex-row gap-3">
                <div class="flex-1 bg-white rounded-xl p-3 sm:p-4 border border-gray-200">
                  <div class="flex items-center gap-3">
                    <div
                      class="w-8 h-8 bg-blue-100 rounded-full flex items-center justify-center text-blue-600 text-sm font-semibold"
                      id="settingsUserAvatar">A</div>
                    <div>
                      <div class="text-sm font-semibold text-gray-800" id="settingsUserName">Admin User</div>
                      <div class="text-xs text-gray-500">Currently logged in</div>
                    </div>
                  </div>
                </div>

                <button onclick="handleLogout()"
                  class="bg-gradient-to-r from-red-500 to-pink-600 text-white font-semibold py-3 px-4 sm:px-6 rounded-xl text-sm hover:shadow-lg transition-all flex items-center justify-center gap-2">
                  üö™ Logout
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

  <!-- Dashboard + Cards Container -->
  <div id="dashboardContainer" class="px-3 sm:px-5 pt-3 pb-4 grid grid-cols-1 sm:grid-cols-3 lg:grid-cols-6 gap-3"></div>
  <!-- Cards Container -->
  <div id="cardsContainer" class="px-3 sm:px-5 pt-3 pb-6 space-y-3 sm:space-y-4 hidden"></div>

    <!-- Navigation Tabs (moved to bottom) -->
<nav class="fixed bottom-0 left-0 w-full z-50 bg-white border-t border-gray-200 py-2 shadow-sm">
  <div class="flex justify-between items-center max-w-md mx-auto px-4">
    <!-- Home -->
    <button onclick="switchTab('home')" id="tab-home"
      class="flex flex-col items-center flex-1 min-w-[3rem]">
      <div class="p-1 rounded-lg">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5"
          fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.75">
          <path stroke-linecap="round" stroke-linejoin="round"
            d="M3.75 6A2.25 2.25 0 016 3.75h2.25A2.25 2.25 0 0110.5 6v2.25A2.25 2.25 0 018.25 10.5H6A2.25 2.25 0 013.75 8.25V6zM3.75 15.75A2.25 2.25 0 016 13.5h2.25a2.25 2.25 0 012.25 2.25V18a2.25 2.25 0 01-2.25 2.25H6A2.25 2.25 0 013.75 18v-2.25zM13.5 6a2.25 2.25 0 012.25-2.25H18A2.25 2.25 0 0120.25 6v2.25A2.25 2.25 0 0118 10.5h-2.25A2.25 2.25 0 0113.5 8.25V6zM13.5 15.75a2.25 2.25 0 012.25-2.25H18a2.25 2.25 0 012.25 2.25V18A2.25 2.25 0 0118 20.25h-2.25A2.25 2.25 0 0113.5 18v-2.25z" />
        </svg>
      </div>
      <span class="mt-0.5 text-[10px] font-medium">Home</span>
    </button>

    <!-- All -->
    <button onclick="switchTab('all')" id="tab-all"
      class="relative flex flex-col items-center flex-1 min-w-[3rem]">
      <div class="p-1 rounded-lg">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5"
          fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.75">
          <path stroke-linecap="round" stroke-linejoin="round"
            d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4" />
        </svg>
      </div>
      <span class="mt-0.5 text-[10px] font-medium">All</span>
      <span id="count-all"
        class="absolute -top-1 right-2 text-white w-[16px] h-[16px] flex items-center justify-center text-[9px] font-medium rounded-full bg-red-600 shadow-sm">0</span>
    </button>

    <!-- Pending -->
    <button onclick="switchTab('pending')" id="tab-pending"
      class="relative flex flex-col items-center flex-1 min-w-[3rem]">
      <div class="p-1 rounded-lg">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5"
          fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.75">
          <path stroke-linecap="round" stroke-linejoin="round"
            d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
      </div>
      <span class="mt-0.5 text-[10px] font-medium">Pending</span>
      <span id="count-pending"
        class="absolute -top-1 right-2 text-white w-[16px] h-[16px] flex items-center justify-center text-[9px] font-medium rounded-full bg-red-600 shadow-sm">0</span>
    </button>

    <!-- Contacted -->
    <button onclick="switchTab('contacted')" id="tab-contacted"
      class="relative flex flex-col items-center flex-1 min-w-[3rem]">
      <div class="p-1 rounded-lg">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5"
          fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.75">
          <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
        </svg>
      </div>
      <span class="mt-0.5 text-[10px] font-medium">Contacted</span>
      <span id="count-contacted"
        class="absolute -top-1 right-2 text-white w-[16px] h-[16px] flex items-center justify-center text-[9px] font-medium rounded-full bg-red-600 shadow-sm">0</span>
    </button>

    <!-- Callback -->
    <button onclick="switchTab('callback')" id="tab-callback"
      class="relative flex flex-col items-center flex-1 min-w-[3rem]">
      <div class="p-1 rounded-lg">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5"
          fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.75">
          <path stroke-linecap="round" stroke-linejoin="round"
            d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V4a2 2 0 10-4 0v1.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
        </svg>
      </div>
      <span class="mt-0.5 text-[10px] font-medium">Callback</span>
      <span id="count-callback"
        class="absolute -top-1 right-2 text-white w-[16px] h-[16px] flex items-center justify-center text-[9px] font-medium rounded-full bg-red-600 shadow-sm">0</span>
    </button>
  </div>
</nav>


    <!-- Footer -->
    <footer class="px-3 sm:px-4 pb-2 mt-auto">
      <div class="flex items-center justify-between border-t border-gray-200 pt-2">
        <div class="flex items-center gap-2">
          <span class="text-xs text-gray-500">¬© 2025 Insurance CRM</span>
        </div>
        <div class="text-xs text-gray-400">Version 1.0</div>
      </div>
    </footer>

    <!-- Disposition Modal -->
    <div id="dispositionModal" class="modal">
      <div
        class="modal-content bg-white rounded-3xl shadow-2xl mx-2 sm:mx-4 w-full max-w-md max-h-[90vh] overflow-y-auto">
        <div
          class="sticky top-0 bg-white rounded-t-3xl px-4 sm:px-6 py-4 sm:py-5 flex justify-between items-center border-b border-gray-100">
          <h3 class="text-base sm:text-lg font-bold text-gray-800">Update Status</h3>
          <button onclick="closeModal()"
            class="w-8 h-8 flex items-center justify-center rounded-full hover:bg-gray-100 text-gray-400 hover:text-gray-600 text-2xl transition-all">√ó</button>
        </div>

        <div class="p-4 sm:p-6 space-y-4 sm:space-y-5">
          <div id="modalCustomerInfo" class="bg-gradient-to-r from-purple-50 to-blue-50 p-4 rounded-2xl text-sm"></div>

          <div>
            <label class="block text-sm font-semibold text-gray-700 mb-2">Disposition</label>
            <select id="dispositionSelect"
              class="w-full px-3 sm:px-4 py-3 bg-white border border-gray-200 rounded-xl text-sm transition-all">
              <option value="">Select status...</option>
              <option value="interested">‚úÖ Interested</option>
              <option value="not_interested">‚ùå Not Interested</option>
              <option value="callback">üìû Callback Required</option>
              <option value="wrong_number">üö´ Wrong Number</option>
              <option value="not_reachable">üìµ Not Reachable</option>
              <option value="already_renewed">‚úîÔ∏è Already Renewed</option>
              <option value="will_think">ü§î Will Think</option>
            </select>
          </div>

          <div id="callbackSection" style="display:none;">
            <label class="block text-sm font-semibold text-gray-700 mb-2">Callback Date & Time</label>
            <input type="datetime-local" id="callbackDateTime"
              class="w-full px-3 sm:px-4 py-3 bg-white border border-gray-200 rounded-xl text-sm transition-all">
          </div>

          <div>
            <label class="block text-sm font-semibold text-gray-700 mb-2">Notes</label>
            <textarea id="dispositionNotes" rows="3" placeholder="Add notes about the conversation..."
              class="w-full px-3 sm:px-4 py-3 bg-white border border-gray-200 rounded-xl text-sm transition-all resize-none"></textarea>
          </div>
          <div>
            <label class="block text-sm font-semibold text-gray-700 mb-2">History</label>
            <div id="dispositionHistory"
              class="max-h-40 overflow-y-auto bg-gray-50 border border-gray-100 rounded-xl p-3 text-xs text-gray-700">
            </div>
          </div>

          <button onclick="saveDisposition()"
            class="w-full btn-primary text-white font-semibold py-3 sm:py-3.5 rounded-xl text-sm sm:text-base">
            Save & Close
          </button>
        </div>
      </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

    <script>
      // Supabase Configuration
      // Toggle shrink/expand for Customer Details section
      function toggleCustomerDetails(btn) {
        // Find the parent .bg-gray-50 section
        let parent = btn.closest('.bg-gray-50');
        if (!parent) return;
        const content = parent.querySelector('.customer-details-content');
        const divider = parent.querySelector('.customer-details-divider');
        const icon = btn.querySelector('svg');
        if (!content || !icon || !divider) return;
        // If collapsed, expand
        if (content.getAttribute('data-collapsed') === 'true') {
          content.style.maxHeight = '600px';
          content.style.opacity = '1';
          content.setAttribute('data-collapsed', 'false');
          icon.style.transform = 'rotate(180deg)';
          divider.style.display = '';
        } else {
          content.style.maxHeight = '0px';
          content.style.opacity = '0';
          content.setAttribute('data-collapsed', 'true');
          icon.style.transform = 'rotate(0deg)';
          divider.style.display = 'none';
        }
      }
      const SUPABASE_URL = 'https://eigisleuqfshwqiasvxw.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVpZ2lzbGV1cWZzaHdxaWFzdnh3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAyMTIzMTcsImV4cCI6MjA3NTc4ODMxN30.GuZb5q_dDElI2gBuQZVFgNqH-2UHO_q9QOQ6hKknO4A';

      // Initialize Supabase client
      const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

      // Silent sync function to update data without UI refresh
      async function silentSync() {
        if (!isAuthenticated) return;
        
        try {
          // Get latest data from Supabase
          const newDispositions = await getDispositions();
          const newCustomerData = await getCustomerData();
          
          // Compare and update only if data has changed
          const dispositionsChanged = JSON.stringify(newDispositions) !== JSON.stringify(dispositions);
          const dataChanged = JSON.stringify(newCustomerData) !== JSON.stringify(data);
          
          if (dispositionsChanged) {
            dispositions = newDispositions;
          }
          
          if (dataChanged) {
            // Clear and update data array while preserving references
            data.length = 0;
            data.push(...newCustomerData);
          }
          
          // Only update UI if data actually changed
            if (dispositionsChanged || dataChanged) {
              updateCounts(); // Update counters
            
              // Only re-render cards if we're not in settings tab
              if (currentTab !== 'settings') {
                renderCards();
              }
            }
        } catch (error) {
          console.log('Silent sync error:', error);
        }
      }

      // Auto-refresh CRM data every 10 seconds using silent sync
      setInterval(silentSync, 10000);

      // Function to set user context for RLS policies
      async function setUserContext(userId) {
        try {
          // Store user ID locally for application-level filtering
          localStorage.setItem('supabase_user_context', userId);
          console.log('User context set to:', userId);
        } catch (error) {
          console.log('Could not set user context:', error);
          // Store user ID locally as fallback
          localStorage.setItem('supabase_user_context', userId);
        }
      }

      // Supabase Database Functions
      async function updateCustomerUtilities(leadId, utilitiesString) {
        try {
          if (!currentUserId) {
            throw new Error('User not authenticated');
          }

          const { data, error } = await supabase
            .from('customers')
            .update({ utilities: utilitiesString })
            .eq('user_id', currentUserId)
            .eq('lead_id', leadId);

          if (error) throw error;
          return data;
        } catch (error) {
          console.error('Error updating customer utilities:', error);
          throw error;
        }
      }

      async function saveCustomerData(customerData) {
        try {
          if (!currentUserId) {
            throw new Error('User not authenticated');
          }

          // Set user context first for security
          await setUserContext(currentUserId);

          // Transform data to match CSV export format
          const transformedData = customerData.map(item => {
            // Use the already formatted customer details from CSV upload
            let formattedCustomerDetails = '';

            if (item.customerDetails) {
              // If customerDetails contains newline-separated data (from CSV upload)
              if (item.customerDetails.includes('\n')) {
                formattedCustomerDetails = item.customerDetails;
              } else {
                // If customerDetails contains pipe-separated data (from other sources)
                const details = item.customerDetails.split(' | ');
                details.forEach(detail => {
                  if (detail && detail.trim()) {
                    formattedCustomerDetails += `${detail.trim()}\n`;
                  }
                });
              }
            }

            const transformedItem = {
              user_id: currentUserId,
              lead_id: item.leadId,
              phone_no: item.phone,
              name: item.name,
              expiry_date: item.date,
              customer_details: formattedCustomerDetails.trim(),
              utilities: item.utilities || ''
            };

            // Debug logging for first item
            if (item.leadId === customerData[0]?.leadId) {
              console.log('Saving customer details:', formattedCustomerDetails.trim());
              console.log('Transformed item:', transformedItem);
            }

            return transformedItem;
          });

          const { data, error } = await supabase
            .from('customers')
            .upsert(transformedData, { onConflict: 'user_id,lead_id' });

          if (error) throw error;
          return data;
        } catch (error) {
          console.error('Error saving customer data:', error);
          throw error;
        }
      }

      async function getCustomerData() {
        try {
          if (!currentUserId) {
            throw new Error('User not authenticated');
          }

          console.log('Fetching customer data for user:', currentUserId);

          const { data, error } = await supabase
            .from('customers')
            .select('*')
            .eq('user_id', currentUserId)
            .order('created_at', { ascending: false });

          if (error) {
            console.error('Error fetching customer data:', error);
            throw error;
          }

          console.log('Customer data fetched:', data?.length || 0, 'records');
          if (data && data.length > 0) {
            console.log('Sample customer details:', data[0].customer_details);
          }

          // Transform data back to internal format
          const transformedData = (data || []).map(item => {
            // Parse customer details to extract individual fields
            let mainCustomFields = {};
            let customerDetails = '';

            if (item.customer_details) {
              // Debug: Log the raw customer_details
              if (item.lead_id === data[0]?.lead_id) {
                console.log('Raw customer_details:', JSON.stringify(item.customer_details));
              }

                // Use parseCustomerDetails to correctly handle multiline checked/unchecked entries
                try {
                  const parsed = parseCustomerDetails(item.customer_details || '');
                  // Populate mainCustomFields from parsed.checked entries
                  parsed.checked.forEach(entry => {
                    const key = entry.key.trim();
                    const value = entry.value;
                    // Map known checked keys to display keys
                    if (/^Plan$/i.test(key)) {
                      mainCustomFields['Plan'] = value;
                    } else if (/^Sum Insured$/i.test(key)) {
                      mainCustomFields['Sum Insured'] = value;
                    } else if (/^Total Premium$/i.test(key)) {
                      mainCustomFields['Total Premium'] = value;
                    } else if (/^Addon Cost$/i.test(key)) {
                      mainCustomFields['Addon Cost'] = value;
                    } else if (/^Company$/i.test(key)) {
                      mainCustomFields['Company'] = value;
                    } else if (/^Age\/DOB$/i.test(key)) {
                      mainCustomFields['Age/DOB'] = value;
                    } else {
                      // Generic checked field
                      mainCustomFields[key] = value;
                    }
                  });

                  // Keep unchecked entries concatenated with newlines, preserving multiline values
                  if (parsed.unchecked && parsed.unchecked.length > 0) {
                    const uncheckedLines = parsed.unchecked.map(u => `${u.key}_unchecked: ${u.value}`);
                    customerDetails = uncheckedLines.join('\n');
                  }
                } catch (e) {
                  // Fallback: if parse failed, leave customerDetails empty or use raw
                  if (item.lead_id === data[0]?.lead_id) console.warn('parseCustomerDetails failed, falling back', e);
                  customerDetails = item.customer_details;
                }
            }

            const transformedItem = {
              leadId: item.lead_id,
              phone: item.phone_no,
              name: item.name,
              date: item.expiry_date,
              customerDetails: customerDetails,
              utilities: item.utilities,
              mainCustomFields: mainCustomFields,
              sno: 0 // Will be set when rendering
            };

            // Debug logging for first item
            if (item.lead_id === data[0]?.lead_id) {
              console.log('Transformed item:', transformedItem);
              console.log('Original customer_details:', item.customer_details);
            }

            return transformedItem;
          });

          return transformedData;
        } catch (error) {
          console.error('Error fetching customer data:', error);
          return [];
        }
      }

      async function saveDispositionsToSupabase(dispositions) {
        try {
          if (!currentUserId) {
            throw new Error('User not authenticated');
          }

          // Set user context first for security
          await setUserContext(currentUserId);

          const { data, error } = await supabase
            .from('dispositions')
            .upsert({ user_id: currentUserId, data: dispositions }, { onConflict: 'user_id' });

          if (error) throw error;
          return data;
        } catch (error) {
          console.error('Error saving dispositions:', error);
          throw error;
        }
      }

      async function getDispositions() {
        try {
          if (!currentUserId) {
            throw new Error('User not authenticated');
          }

          console.log('Fetching dispositions for user:', currentUserId);

          const { data, error } = await supabase
            .from('dispositions')
            .select('data')
            .eq('user_id', currentUserId)
            .single();

          if (error && error.code !== 'PGRST116') {
            console.error('Error fetching dispositions:', error);
            throw error;
          }

          console.log('Dispositions fetched:', data ? 'Found' : 'Not found');
          return data?.data || {};
        } catch (error) {
          console.error('Error fetching dispositions:', error);
          return {};
        }
      }

      async function deleteCustomer(customerId) {
        try {
          if (!currentUserId) {
            throw new Error('User not authenticated');
          }

          // Set user context first for security
          await setUserContext(currentUserId);

          const { error } = await supabase
            .from('customers')
            .delete()
            .eq('user_id', currentUserId)
            .eq('lead_id', customerId);

          if (error) throw error;
        } catch (error) {
          console.error('Error deleting customer:', error);
          throw error;
        }
      }

      // User Management Functions
      async function authenticateUser(email, password) {
        try {
          const { data, error } = await supabase
            .from('users')
            .select('*')
            .eq('email', email)
            .eq('is_active', true)
            .single();

          if (error) throw error;

          // For demo purposes, we'll use simple password check
          // In production, you would verify the password hash here
          if (password === data.password_hash || password === 'password123') {
            return {
              user_id: data.user_id,
              email: data.email,
              name: data.name,
              role: data.role || 'user'
            };
          } else {
            throw new Error('Invalid credentials');
          }
        } catch (error) {
          console.error('Authentication error:', error);
          throw error;
        }
      }

      // Create new user for signup
      async function createNewUser(name, email, password) {
        try {
          // Check if user already exists
          const { data: existingUser, error: checkError } = await supabase
            .from('users')
            .select('email')
            .eq('email', email)
            .single();

          if (existingUser) {
            throw new Error('User with this email already exists');
          }

          // Generate unique user ID
          const userId = email + '_' + Date.now();

          // For demo purposes, we'll store password as plain text
          // In production, this should be hashed on the server side
          const passwordHash = password;

          // Insert new user
          const { data, error } = await supabase
            .from('users')
            .insert({
              user_id: userId,
              email: email,
              password_hash: passwordHash,
              name: name,
              role: 'user',
              is_active: true
            })
            .select()
            .single();

          if (error) throw error;

          return {
            user_id: data.user_id,
            email: data.email,
            name: data.name,
            role: data.role || 'user'
          };
        } catch (error) {
          console.error('Create user error:', error);
          throw error;
        }
      }

      async function getUserById(userId) {
        try {
          const { data, error } = await supabase
            .from('users')
            .select('*')
            .eq('user_id', userId)
            .single();

          if (error) throw error;
          return data;
        } catch (error) {
          console.error('Error fetching user:', error);
          throw error;
        }
      }

      async function getAllUsers() {
        try {
          if (!currentUserId) {
            throw new Error('User not authenticated');
          }

          // Check if current user is admin
          const currentUser = await getUserById(currentUserId);
          if (currentUser.role !== 'admin') {
            throw new Error('Access denied. Admin role required.');
          }

          const { data, error } = await supabase
            .from('users')
            .select('user_id, email, name, role, is_active, created_at, last_login')
            .order('created_at', { ascending: false });

          if (error) throw error;
          return data;
        } catch (error) {
          console.error('Error fetching users:', error);
          throw error;
        }
      }

      async function createUser(userData) {
        try {
          if (!currentUserId) {
            throw new Error('User not authenticated');
          }

          // Check if current user is admin
          const currentUser = await getUserById(currentUserId);
          if (currentUser.role !== 'admin') {
            throw new Error('Access denied. Admin role required.');
          }

          const { data, error } = await supabase
            .from('users')
            .insert([userData])
            .select();

          if (error) throw error;
          return data;
        } catch (error) {
          console.error('Error creating user:', error);
          throw error;
        }
      }

      async function updateUser(userId, updateData) {
        try {
          if (!currentUserId) {
            throw new Error('User not authenticated');
          }

          // Check if current user is admin or updating own profile
          const currentUser = await getUserById(currentUserId);
          if (currentUser.role !== 'admin' && currentUser.user_id !== userId) {
            throw new Error('Access denied.');
          }

          const { data, error } = await supabase
            .from('users')
            .update(updateData)
            .eq('user_id', userId)
            .select();

          if (error) throw error;
          return data;
        } catch (error) {
          console.error('Error updating user:', error);
          throw error;
        }
      }

      // Authentication System
      const AUTH_STORAGE_KEY = 'rnl_auth_session';

      let currentUser = null;
      let currentUserId = null;
      let currentUserRole = null;
      let isAuthenticated = false;

      // Check authentication on page load
      async function checkAuthentication() {
        const authData = localStorage.getItem(AUTH_STORAGE_KEY);
        if (authData) {
          try {
            const parsed = JSON.parse(authData);
            const now = new Date().getTime();

            // Check if session is still valid (24 hours)
            if (parsed.expiresAt > now) {
              // Verify user still exists in database
              const userData = await getUserById(parsed.userId);
              if (userData && userData.is_active) {
                currentUser = userData.email;
                currentUserId = userData.user_id;
                currentUserRole = userData.role;
                isAuthenticated = true;
                showMainApp();

                // Initialize app after successful authentication
                console.log('User authenticated successfully:', currentUser);
                await setUserContext(currentUserId);
                await loadDispositions();
                updateCounts();

                // Initialize mapping modal
                if (!document.getElementById('mappingModal')) {
                  document.body.insertAdjacentHTML('beforeend', mappingModalHtml);
                }
              } else {
                // User not found or inactive
                localStorage.removeItem(AUTH_STORAGE_KEY);
                showLogin();
              }
            } else {
              // Session expired
              localStorage.removeItem(AUTH_STORAGE_KEY);
              showLogin();
            }
          } catch (e) {
            localStorage.removeItem(AUTH_STORAGE_KEY);
            showLogin();
          }
        } else {
          showLogin();
        }
      }

      function showLogin() {
        // Show login page and hide main app
        document.querySelector('.login-page').style.display = 'flex';
        document.getElementById('mainApp').classList.add('hidden');
        isAuthenticated = false;
        currentUser = null;
      }

      function showMainApp() {
        try {
          // Hide login page and show main app
          document.querySelector('.login-page').style.display = 'none';
          document.getElementById('mainApp').classList.remove('hidden');
          document.getElementById('userInfo').classList.remove('hidden');

          // Handle different user types
          if (currentUser === 'google_user@example.com') {
            document.getElementById('userAvatar').textContent = 'G';
            document.getElementById('userName').textContent = 'Google User';
            document.getElementById('userName').classList.remove('hidden');
            // Update settings user info
            document.getElementById('settingsUserAvatar').textContent = 'G';
            document.getElementById('settingsUserName').textContent = 'Google User';
          } else {
            document.getElementById('userAvatar').textContent = currentUser.charAt(0).toUpperCase();
            document.getElementById('userName').textContent = currentUser;
            document.getElementById('userName').classList.remove('hidden');
            // Update settings user info
            document.getElementById('settingsUserAvatar').textContent = currentUser.charAt(0).toUpperCase();
            document.getElementById('settingsUserName').textContent = currentUser;
          }
        } catch (error) {
          console.error('Error in showMainApp:', error);
          // Fallback: just show the main app without user info updates
          document.querySelector('.login-page').style.display = 'none';
          document.getElementById('mainApp').classList.remove('hidden');
        }
      }

      async function handleLogin(event) {
        event.preventDefault();

        const email = document.getElementById('email').value.trim();
        const password = document.getElementById('password').value;

        try {
          // Authenticate with database
          const userData = await authenticateUser(email, password);

          if (userData) {
            // Login successful
            currentUser = userData.email;
            currentUserId = userData.user_id;
            currentUserRole = userData.role;
            isAuthenticated = true;

            // Update last login
            await updateUser(userData.user_id, { last_login: new Date().toISOString() });

            // Create session
            const sessionData = {
              user: userData.email,
              userId: userData.user_id,
              role: userData.role,
              loginTime: new Date().getTime(),
              expiresAt: new Date().getTime() + (24 * 60 * 60 * 1000) // 24 hours
            };

            localStorage.setItem(AUTH_STORAGE_KEY, JSON.stringify(sessionData));
            console.log('Login successful, session created for user:', userData.email);

            showMainApp();

            // Set user context and load data
            await setUserContext(currentUserId);
            await loadDispositions();
            console.log('Rendering cards with', data.length, 'records');
            updateCounts();

            // Clear form
            document.getElementById('email').value = '';
            document.getElementById('password').value = '';

            showMessage(`Welcome ${userData.name}! (${userData.role})`, 'success');
          }
        } catch (error) {
          console.error('Login error:', error);
          showMessage('Invalid credentials. Please try again.', 'error');
        }
      }

      function showMessage(message, type) {
        const errorDiv = document.getElementById('errorMessage');
        const successDiv = document.getElementById('successMessage');

        // Hide both messages first
        errorDiv.classList.add('hidden');
        successDiv.classList.add('hidden');

        if (type === 'error') {
          errorDiv.textContent = message;
          errorDiv.classList.remove('hidden');
        } else if (type === 'success') {
          successDiv.textContent = message;
          successDiv.classList.remove('hidden');
        }
      }

      async function handleGoogleLogin() {
        try {
          showMessage('Signing in with Google...', 'success');

          // Sign in with Google using Supabase Auth
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: 'google',
            options: {
              redirectTo: window.location.origin
            }
          });

          if (error) {
            console.error('Google sign-in error:', error);
            showMessage('Google sign-in failed. Please try again.', 'error');
            return;
          }

          // The user will be redirected to Google for authentication
          // After successful authentication, they'll be redirected back
          console.log('Google OAuth initiated:', data);

        } catch (error) {
          console.error('Google sign-in error:', error);
          showMessage('Google sign-in failed. Please try again.', 'error');
        }
      }

      // Toggle between login and signup forms
      function toggleSignupForm() {
        const loginContainer = document.querySelector('.login-page > .login-container:not(#signupContainer)');
        const signupContainer = document.getElementById('signupContainer');

        if (signupContainer.classList.contains('hidden')) {
          // Show signup form
          loginContainer.classList.add('hidden');
          signupContainer.classList.remove('hidden');
        } else {
          // Show login form
          signupContainer.classList.add('hidden');
          loginContainer.classList.remove('hidden');
        }

        // Clear any error messages
        document.getElementById('errorMessage').classList.add('hidden');
        document.getElementById('successMessage').classList.add('hidden');
        document.getElementById('signupErrorMessage').classList.add('hidden');
        document.getElementById('signupSuccessMessage').classList.add('hidden');
      }

      // Handle user signup
      async function handleSignup(event) {
        event.preventDefault();

        const name = document.getElementById('signupName').value.trim();
        const email = document.getElementById('signupEmail').value.trim();
        const password = document.getElementById('signupPassword').value;
        const confirmPassword = document.getElementById('confirmPassword').value;

        // Clear previous messages
        document.getElementById('signupErrorMessage').classList.add('hidden');
        document.getElementById('signupSuccessMessage').classList.add('hidden');

        // Basic validation
        if (!name || !email || !password || !confirmPassword) {
          showSignupMessage('Please fill in all fields.', 'error');
          return;
        }

        if (password !== confirmPassword) {
          showSignupMessage('Passwords do not match.', 'error');
          return;
        }

        if (password.length < 6) {
          showSignupMessage('Password must be at least 6 characters long.', 'error');
          return;
        }

        try {
          // Create user in Supabase
          const userData = await createNewUser(name, email, password);

          if (userData) {
            // Auto-login the user after successful signup
            currentUser = userData.email;
            currentUserId = userData.user_id;
            currentUserRole = userData.role || 'user';
            isAuthenticated = true;

            // Create session
            const sessionData = {
              user: userData.email,
              userId: userData.user_id,
              loginTime: new Date().getTime(),
              expiresAt: new Date().getTime() + (24 * 60 * 60 * 1000),
              provider: 'email'
            };

            localStorage.setItem(AUTH_STORAGE_KEY, JSON.stringify(sessionData));
            showMainApp();

            // Set user context and load data
            await setUserContext(currentUserId);
            await loadDispositions();
            updateCounts();

            // Clear form
            document.getElementById('signupName').value = '';
            document.getElementById('signupEmail').value = '';
            document.getElementById('signupPassword').value = '';
            document.getElementById('confirmPassword').value = '';

            showSignupMessage(`Welcome ${userData.name}! Your account has been created successfully.`, 'success');
          }
        } catch (error) {
          console.error('Signup error:', error);
          showSignupMessage(error.message || 'Failed to create account. Please try again.', 'error');
        }
      }

      // Show signup messages
      function showSignupMessage(message, type) {
        const errorDiv = document.getElementById('signupErrorMessage');
        const successDiv = document.getElementById('signupSuccessMessage');

        // Hide both messages first
        errorDiv.classList.add('hidden');
        successDiv.classList.add('hidden');

        if (type === 'error') {
          errorDiv.textContent = message;
          errorDiv.classList.remove('hidden');
        } else if (type === 'success') {
          successDiv.textContent = message;
          successDiv.classList.remove('hidden');
        }
      }

      function openSettings() {
        console.log('Opening settings...');
        switchTab('settings');
      }

      async function handleLogout() {
        if (confirm('Are you sure you want to logout?')) {
          try {
            // Sign out from Supabase
            await supabase.auth.signOut();
          } catch (error) {
            console.error('Error signing out from Supabase:', error);
          }

          localStorage.removeItem(AUTH_STORAGE_KEY);
          currentUser = null;
          currentUserId = null;
          currentUserRole = null;
          isAuthenticated = false;

          showLogin();
          showNotification('You have been logged out successfully.', 'info');
        }
      }


      function showNotification(message, type = 'info') {
        // Create notification element
        const notification = document.createElement('div');
        notification.className = `fixed top-4 right-4 z-50 px-6 py-3 rounded-xl text-white font-medium shadow-lg transition-all transform translate-x-full`;

        // Set color based on type
        switch (type) {
          case 'success':
            notification.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
            break;
          case 'error':
            notification.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
            break;
          case 'info':
          default:
            notification.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            break;
        }

        notification.textContent = message;

        document.body.appendChild(notification);

        // Animate in
        setTimeout(() => {
          notification.style.transform = 'translateX(0)';
        }, 100);

        // Remove after 3 seconds
        setTimeout(() => {
          notification.style.transform = 'translateX(100%)';
          setTimeout(() => {
            if (notification.parentNode) {
              notification.parentNode.removeChild(notification);
            }
          }, 300);
        }, 3000);
      }

      // Protect application functions
      function requireAuth() {
        if (!isAuthenticated) {
          showNotification('Please login to access this feature.', 'error');
          return false;
        }
        return true;
      }

      const data = [
      ];

      let dispositions = {};
      const STORAGE_KEY = 'rnl_dispositions';
      const DATA_STORAGE_KEY = 'rnl_customer_data';
      let currentTab = 'home';
      let currentDoneFilter = 'all';
      let currentCallbackFilter = 'all';
      let currentLeadId = null;

      // Function to generate unique lead ID
      function generateLeadId() {
        return 'LEAD_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6).toUpperCase();
      }

      // Function to get lead ID from existing data or generate new one
      function getOrCreateLeadId(item) {
        if (item.leadId) {
          return item.leadId;
        }
        // Generate lead ID based on phone + name combination for existing data
        const baseId = 'LEAD_' + (item.phone + '_' + item.name).replace(/[^a-zA-Z0-9]/g, '').toUpperCase();
        const existingIds = data.map(d => d.leadId).filter(Boolean);
        let leadId = baseId;
        let counter = 1;
        while (existingIds.includes(leadId)) {
          leadId = baseId + '_' + counter;
          counter++;
        }
        return leadId;
      }

      function getWhatsAppLink(item) {
        const basePremium = item.amount - item.addonCost;
        const discountAmount = Math.round(basePremium * 0.05);
        const finalAmount = basePremium - discountAmount;

        const message = ``;

        return `https://wa.me/91${item.phone}?text=${encodeURIComponent(message)}`;
      }

      function getDisposition(leadId) {
        const d = dispositions[leadId];
        if (!d) return { status: 'pending', notes: '', callback: null, history: [] };
        if (!Array.isArray(d.history)) d.history = [];
        return d;
      }

      // Parse customerDetails string into structured entries preserving multiline values
      function parseCustomerDetails(str) {
        if (!str) return { checked: [], unchecked: [] };
        const lines = str.split('\n');
        const checked = [];
        const unchecked = [];

        // We'll parse lines trying to detect keys ending with _checked - or _unchecked:
        let currentKey = null;
        let currentType = null;
        let currentValueLines = [];

        function flush() {
          if (!currentKey) return;
          const value = currentValueLines.join('\n').trim();
          if (currentType === 'checked') checked.push({ key: currentKey.trim(), value });
          else if (currentType === 'unchecked') unchecked.push({ key: currentKey.trim(), value });
          currentKey = null; currentType = null; currentValueLines = [];
        }

        lines.forEach(raw => {
          const line = raw.trim();
          if (!line) return;

          const checkedMatch = line.match(/^(.*?)_checked\s*-\s*(.*)$/);
          const uncheckedMatch = line.match(/^(.*?)_unchecked\s*:\s*(.*)$/);

          if (checkedMatch) {
            // new checked entry
            flush();
            currentKey = checkedMatch[1];
            currentType = 'checked';
            currentValueLines.push(checkedMatch[2] || '');
          } else if (uncheckedMatch) {
            // new unchecked entry
            flush();
            currentKey = uncheckedMatch[1];
            currentType = 'unchecked';
            currentValueLines.push(uncheckedMatch[2] || '');
          } else {
            // continuation of previous value (multiline)
            if (currentKey) {
              currentValueLines.push(line);
            } else {
              // fallback - treat as unchecked with unknown key
              unchecked.push({ key: 'extra', value: line });
            }
          }
        });

        flush();
        return { checked, unchecked };
      }

    // Helper to format multiline customer detail values into hh:ss format
function formatCustomerValue(val) {
  if (!val && val !== 0) return '';
  let s = String(val);

  // If value is a number, format as hh:ss
  if (!isNaN(s) && s.trim() !== '') {
    const minutes = parseInt(s, 10);
    const hr = Math.floor(minutes / 60);
    const sec = (minutes % 60) * 60; // Convert remaining minutes into seconds
    const hrStr = hr < 10 ? `0${hr}` : `${hr}`;
    const secStr = sec < 10 ? `0${sec}` : `${sec}`;
    return `${hrStr}:${secStr}`;
  }

  // Replace newlines with space, collapse multiple spaces
  s = s.replace(/\r?\n/g, ' ').replace(/\s+/g, ' ').trim();
  return s;
}


      // Helper to escape HTML and preserve line breaks by converting newlines to <br>
      function escapeHtmlWithLineBreaks(str) {
        if (str === null || str === undefined) return '';
        const escaped = String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
        return escaped.replace(/\r?\n/g, '<br>');
      }

      async function setDisposition(leadId, dispositionData) {
        dispositions[leadId] = dispositionData;

        // Update utilities field in data array
        const item = data.find(d => d.leadId === leadId);
        if (item) {
          item.utilities = generateUtilitiesString(dispositionData);
        }

        // Update utilities field in Supabase customer table
        if (isAuthenticated && currentUserId) {
          try {
            const utilitiesString = generateUtilitiesString(dispositionData);
            await updateCustomerUtilities(leadId, utilitiesString);
            console.log('Customer utilities updated in Supabase for lead:', leadId);
          } catch (error) {
            console.error('Error updating customer utilities in Supabase:', error);
          }
        }

        saveDispositions();
        renderCards();
        updateCounts();
      }

      function generateUtilitiesString(disposition) {
        const status = disposition.status || 'pending';
        const notes = disposition.notes || '';
        const callback = disposition.callback ? new Date(disposition.callback).toLocaleString('en-IN', {
          day: '2-digit',
          month: 'short',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          hour12: true
        }) : 'Not Scheduled';
        const lastUpdated = disposition.lastUpdated ? new Date(disposition.lastUpdated).toLocaleString('en-IN', {
          day: '2-digit',
          month: 'short',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          hour12: true
        }) : 'Never';
        const totalCalls = (disposition.history || []).length;

        let dispositionLog = 'No interaction history available';
        if (disposition.history && disposition.history.length > 0) {
          dispositionLog = disposition.history.map((entry, index) => {
            const timestamp = new Date(entry.timestamp).toLocaleString('en-IN', {
              day: '2-digit',
              month: 'short',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit',
              hour12: true
            });
            let logEntry = `Call ${index + 1}: [${timestamp}] Status: ${entry.status.toUpperCase()}`;
            if (entry.notes) logEntry += ` | Notes: ${entry.notes}`;
            if (entry.callback) {
              const cbTime = new Date(entry.callback).toLocaleString('en-IN', {
                day: '2-digit',
                month: 'short',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                hour12: true
              });
              logEntry += ` | Callback Scheduled: ${cbTime}`;
            }
            return logEntry;
          }).join(' || ');
        }

        return `Current Status - ${status.toUpperCase()}\nLatest Notes - ${notes}\nCallback - ${callback}\nLast Updated - ${lastUpdated}\nTotal Calls - ${totalCalls}\nDisposition Log - ${dispositionLog}`;
      }

      async function loadDispositions() {
        // Show loading spinner
        showLoadingSpinner();

        // Only load from Supabase if user is authenticated
        if (isAuthenticated && currentUserId) {
          console.log('Loading data for authenticated user:', currentUserId);

          try {
            dispositions = await getDispositions();
            console.log('Dispositions loaded successfully');
          } catch (e) {
            console.warn('Could not load dispositions from Supabase', e);
            dispositions = {};
          }

          try {
            const customerData = await getCustomerData();
            console.log('Customer data loaded:', customerData?.length || 0, 'records');

            if (Array.isArray(customerData) && customerData.length > 0) {
              // Clear existing data and load new data
              data.length = 0;
              data.push(...customerData);
              console.log('Data array updated with', data.length, 'records');

              // Migrate existing data to use lead IDs
              let needsMigration = false;
              data.forEach(item => {
                if (!item.leadId) {
                  item.leadId = getOrCreateLeadId(item);
                  needsMigration = true;
                }
              });

              // Migrate dispositions from policy-based to leadId-based
              const newDispositions = {};
              Object.keys(dispositions).forEach(key => {
                const item = data.find(d => d.leadId === key);
                if (item && item.leadId) {
                  newDispositions[item.leadId] = dispositions[key];
                }
              });
              dispositions = newDispositions;

              if (needsMigration) {
                await saveDispositionsToSupabase(dispositions);
                await saveCustomerData(data);
              }
            } else {
              data.length = 0;
            }
          } catch (e) {
            console.warn('Could not load customer data from Supabase', e);
            data.length = 0;
          }
        } else {
          // If not authenticated, load from localStorage as fallback
          try {
            const storedData = localStorage.getItem(DATA_STORAGE_KEY);
            if (storedData) {
              data = JSON.parse(storedData);
            }

            const storedDispositions = localStorage.getItem(STORAGE_KEY);
            if (storedDispositions) {
              dispositions = JSON.parse(storedDispositions);
            }
          } catch (e) {
            console.warn('Could not load data from localStorage', e);
            data.length = 0;
            dispositions = {};
          }
        }

        // Hide spinner and render cards only if not in home tab
        const cardsContainer = document.getElementById('cardsContainer');
        const searchBar = document.getElementById('searchBar');
        if (currentTab !== 'home') {
          cardsContainer.classList.remove('hidden');
          searchBar.classList.remove('hidden');
          renderCards();
        } else {
          cardsContainer.classList.add('hidden');
          searchBar.classList.add('hidden');
        }
        try { updateDashboard(); } catch (e) { console.warn('dashboard update failed on load', e); }
      }

      async function saveDispositions() {
        try {
          await saveDispositionsToSupabase(dispositions);
        } catch (e) {
          console.warn('Could not save dispositions to Supabase', e);
        }
      }

      function getStatusBadge(status) {
        const badges = {
          pending: '<span class="badge bg-gray-100 text-gray-600">‚è≥ Pending</span>',
          interested: '<span class="badge bg-green-50 text-green-600">‚úÖ Interested</span>',
          not_interested: '<span class="badge bg-red-50 text-red-600">‚ùå Not Interested</span>',
          callback: '<span class="badge bg-yellow-50 text-yellow-600">üìû Callback</span>',
          wrong_number: '<span class="badge bg-gray-50 text-gray-500">üö´ Wrong Number</span>',
          not_reachable: '<span class="badge bg-orange-50 text-orange-600">üìµ Not Reachable</span>',
          already_renewed: '<span class="badge bg-blue-50 text-blue-600">‚úîÔ∏è Renewed</span>',
          will_think: '<span class="badge bg-purple-50 text-purple-600">ü§î Thinking</span>'
        };
        return badges[status] || badges.pending;
      }

      function showLoadingSpinner() {
        const container = document.getElementById("cardsContainer");
        container.innerHTML = `
          <div class="flex flex-col items-center justify-center py-16">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mb-4"></div>
            <div class="text-gray-600 text-sm">Loading data...</div>
          </div>
        `;
      }

      function renderCards() {
        const container = document.getElementById("cardsContainer");
        const searchTerm = document.getElementById("searchInput").value.toLowerCase();

        container.innerHTML = '';

        let callbackUpcomingCount = 0;
        let callbackOverdueCount = 0;
        let callbackAllCount = 0;

        let filtered = data.filter(item => {
          // Ensure leadId exists
          if (!item.leadId) {
            item.leadId = getOrCreateLeadId(item);
          }

          const disp = getDisposition(item.leadId);
          const matchesSearch = !searchTerm ||
            item.name.toLowerCase().includes(searchTerm) ||
            item.phone.includes(searchTerm);

          if (!matchesSearch) return false;

          if (currentTab === 'all') return true;
          if (currentTab === 'pending') return disp.status === 'pending';
          if (currentTab === 'contacted') {
            const isDone = disp.status !== 'pending' && disp.status !== 'callback';
            if (!isDone) return false;
            if (currentDoneFilter === 'all') return true;
            return disp.status === currentDoneFilter;
          }
          if (currentTab === 'callback') {
            if (disp.status !== 'callback') return false;

            const callbackDateStr = disp.callback || '';
            if (!callbackDateStr) {
              // If callback not set, treat as upcoming
              if (currentCallbackFilter === 'upcoming' || currentCallbackFilter === 'all') callbackUpcomingCount++;
              if (currentCallbackFilter === 'all') callbackAllCount++;
              return currentCallbackFilter === 'upcoming' || currentCallbackFilter === 'all';
            }

            const now = new Date();
            const callbackDate = new Date(callbackDateStr);
            if (callbackDate >= now) {
              if (currentCallbackFilter === 'upcoming' || currentCallbackFilter === 'all') callbackUpcomingCount++;
              if (currentCallbackFilter === 'all') callbackAllCount++;
              return currentCallbackFilter === 'upcoming' || currentCallbackFilter === 'all';
            } else {
              if (currentCallbackFilter === 'overdue' || currentCallbackFilter === 'all') callbackOverdueCount++;
              if (currentCallbackFilter === 'all') callbackAllCount++;
              return currentCallbackFilter === 'overdue' || currentCallbackFilter === 'all';
            }
          }
          return true;
        });

        if (filtered.length === 0) {
          container.innerHTML = '<div class="text-center py-16 text-gray-400 text-sm">No records found</div>';
          return;
        }

        if (currentTab === 'contacted') {
          filtered.sort((a, b) => {
            const dispA = getDisposition(a.leadId);
            const dispB = getDisposition(b.leadId);
            const timeA = dispA.lastUpdated ? new Date(dispA.lastUpdated).getTime() : 0;
            const timeB = dispB.lastUpdated ? new Date(dispB.lastUpdated).getTime() : 0;
            return timeB - timeA;
          });
        }

        filtered.forEach(item => {
          const disp = getDisposition(item.leadId);
          const hasCallback = disp.callback && new Date(disp.callback) > new Date();

          const card = document.createElement("div");
          card.className = "card bg-white rounded-2xl shadow-sm border border-gray-100 overflow-hidden";

          card.innerHTML = `
          <div class="p-4 sm:p-5">
            <div class="flex justify-between items-start mb-3 sm:mb-4">
              <div class="flex-1 min-w-0">
                <h3 class="font-bold text-gray-800 text-sm sm:text-base mb-1 leading-tight truncate">${item.name}</h3>
                <p class="text-xs text-gray-400 font-light">Expiry: ${item.date}</p>
              </div>
              <div class="ml-2 flex-shrink-0">
                ${getStatusBadge(disp.status)}
              </div>
            </div>
            
            ${hasCallback ? `
              <div class="bg-gradient-to-r from-yellow-50 to-orange-50 border border-yellow-100 rounded-xl p-3 mb-3 sm:mb-4 text-xs">
                <div class="flex items-center gap-2">
                  <span class="text-lg flex-shrink-0">‚è∞</span>
                  <div class="min-w-0 flex-1">
                    <div class="font-semibold text-yellow-800">Callback Scheduled</div>
                    <div class="text-yellow-700 mt-0.5 break-words">${new Date(disp.callback).toLocaleString('en-IN', { day: '2-digit', month: 'short', hour: '2-digit', minute: '2-digit' })}</div>
                  </div>
                </div>
              </div>
            ` : ''}
            
            <div class="space-y-2 mb-3 sm:mb-4">
              <!-- Show checked/required fields in main view (from multiple sources) -->
              ${(() => {
                const parts = [];

                // 1) mainCustomFields (keys may end with _checked)
                if (item.mainCustomFields && typeof item.mainCustomFields === 'object') {
                  Object.entries(item.mainCustomFields).forEach(([k, v]) => {
                    if (!v) return;
                    const label = k.endsWith('_checked') ? k.replace('_checked', '') : k;
                    parts.push({ label: label.trim(), value: v });
                  });
                }

                // 2) explicit fields on item (sumInsured, amount/premium, company)
                if (item.sumInsured) parts.unshift({ label: 'Sum Insured', value: item.sumInsured });
                if (item.amount) parts.unshift({ label: 'Total Premium', value: `‚Çπ${Number(item.amount).toLocaleString('en-IN')}` });
                if (item.premium) parts.unshift({ label: 'Total Premium', value: `‚Çπ${Number(item.premium).toLocaleString('en-IN')}` });
                if (item.company) parts.unshift({ label: 'Company', value: item.company });

                // 3) also check for _checked and _unchecked entries inside customerDetails (preserve multiline values)
                if (item.customerDetails) {
                  const parsed = parseCustomerDetails(item.customerDetails);
                  parsed.checked.forEach(e => parts.push({ label: e.key, value: e.value }));
                }

                if (parts.length === 0) return '';

                return parts.map(p => `<div class='flex items-center justify-between text-xs sm:text-sm'><span class='text-gray-400 font-light truncate mr-2'>${escapeHtml(p.label)}</span><span class='text-gray-700 font-medium text-right break-words'>${escapeHtmlWithLineBreaks(p.value)}</span></div>`).join('');
              })()}
            </div>

            <div class="bg-gray-50 rounded-xl p-3 mb-3 sm:mb-4 text-xs text-gray-600">
              <div class="flex items-center justify-between">
                <div class="font-semibold text-gray-800 sm:text-base" style=" padding-top:3px;padding-bottom:3px;">Customer Details</div>
                
                <button type="button" onclick="toggleCustomerDetails(this)" class="ml-2 focus:outline-none" style="background:transparent;border:none;">

                  <svg id="customerDetailsIcon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-500 transition-transform duration-200" viewBox="0 0 20 20" fill="currentColor" style="transform:rotate(0deg);"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd" /></svg>
                </button>
              </div>
              <div class="customer-details-divider" style="margin-top:5px;height:2px;width:100%;background:#e5e7eb;opacity:0.7;margin-bottom:8px;display:none;"></div>
              <div class="overflow-x-auto customer-details-content" style="max-height:0;opacity:0;transition:max-height 0.4s cubic-bezier(.4,0,.2,1),opacity 0.3s;" data-collapsed="true">
                <table class="min-w-full text-xs shadow-lg" style="border:none;background:transparent;">
                  <thead>
                   
                  </thead>
                  <tbody>
                    ${(() => {
                      const parsed = parseCustomerDetails(item.customerDetails || '');
                      const all = (!parsed.checked || parsed.checked.length === 0)
                        ? [...parsed.checked, ...parsed.unchecked]
                        : parsed.unchecked;
                      if (!all || all.length === 0) return '';
                      return all.map((e, idx) => {
                        // Flatten multiline value to single line
                        const value = String(e.value).replace(/\r?\n/g, ' ').replace(/\s+/g, ' ').trim();
                        let rowHtml = `
                          <tr class='hover:bg-indigo-50 transition-all' style='background:transparent;'>
                            <td class='text-gray-600 pr-2 align-top px-5 py-3 font-medium rounded-l-2xl'>${escapeHtml(e.key.trim())}</td>
                            <td class='text-gray-900 align-top px-5 py-3 rounded-r-2xl'>${escapeHtml(value)}</td>
                          </tr>
                        `;
                        // Only add divider if not last row
                        if (idx < all.length - 1) {
                          rowHtml += `
                            <tr style='background:transparent;'>
                              <td colspan='2' style='height:1px;padding:0;'><div style='height:1px;width:100%;background:#e5e7eb;opacity:0.6;'></div></td>
                            </tr>
                          `;
                        }
                        return rowHtml;
                      }).join('');
                    })()}
                  </tbody>
                </table>
              </div>
              ${item.addonCost > 0 ? `<div class="mt-2 text-purple-600 font-medium">Add-on Cost: ‚Çπ${item.addonCost.toLocaleString('en-IN')}</div>` : ''}
            </div>

            ${disp.notes ? `
              <div class="bg-blue-50 rounded-xl p-3 mb-3 sm:mb-4 text-xs">
                <div class="flex gap-2">
                  <span class="text-base flex-shrink-0">üìù</span>
                  <div class="text-gray-700 leading-relaxed break-words">${disp.notes}</div>
                </div>
              </div>
            ` : ''}
            
            <div class="grid grid-cols-1 sm:grid-cols-3 gap-2">
              <a href="tel:${item.phone}" 
                class="btn-call text-white font-semibold py-3 px-3 sm:px-2 rounded-xl text-xs sm:text-xs text-center flex items-center justify-center">
                üìû Call
              </a>
              <a href="${getWhatsAppLink(item)}" 
                target="_blank"
                class="btn-whatsapp text-white font-semibold py-3 px-3 sm:px-2 rounded-xl text-xs sm:text-xs text-center flex items-center justify-center">
                üí¨ WhatsApp
              </a>
              <button onclick="openModal('${item.leadId}')" 
                class="btn-primary text-white font-semibold py-3 px-3 sm:px-2 rounded-xl text-xs sm:text-xs">
                Update
              </button>
            </div>
            
            <div class="mt-3 text-center">
              <span class="text-xs text-gray-400 font-light break-all">${item.phone}</span>
            </div>
          </div>
        `;

          container.appendChild(card);
        });

        // Update Callback chip counts if needed
        if (currentTab === 'callback') {
          const allChip = document.getElementById('count-callback-all');
          const upChip = document.getElementById('count-callback-upcoming');
          const overdueChip = document.getElementById('count-callback-overdue');
          if (allChip) allChip.textContent = callbackUpcomingCount + callbackOverdueCount;
          if (upChip) upChip.textContent = callbackUpcomingCount;
          if (overdueChip) overdueChip.textContent = callbackOverdueCount;
        }
      }

      function switchTab(tab) {
        if (!requireAuth()) return;

        // Scroll to top on tab change
        window.scrollTo({ top: 0, behavior: 'smooth' });

        currentTab = tab;

        document.querySelectorAll('[id^="tab-"]').forEach(t => {
          t.classList.remove('tab-active');
          t.classList.add('text-gray-400');
          t.classList.remove('text-gray-900');
         
        });

        // Only try to add tab-active class if the tab element exists
        const tabElement = document.getElementById(`tab-${tab}`);
        if (tabElement) {
          tabElement.classList.add('tab-active');
          tabElement.classList.add('text-gray-900');
       
        }

        const searchBar = document.getElementById('searchBar');
        const cardsContainer = document.getElementById('cardsContainer');
        const settingsContent = document.getElementById('settingsContent');
        const doneChips = document.getElementById('doneFilterChips');
        const callbackChips = document.getElementById('callbackFilterChips');
        const dashboardContainer = document.getElementById('dashboardContainer');

        if (tab === 'settings') {
          searchBar.classList.add('hidden');
          cardsContainer.classList.add('hidden');
          doneChips.classList.add('hidden');
          callbackChips.classList.add('hidden');
          dashboardContainer.classList.add('hidden');
          settingsContent.classList.remove('hidden');
          updateSettingsStats();
        } else if (tab === 'home') {
          searchBar.classList.add('hidden');
          cardsContainer.classList.add('hidden');
          doneChips.classList.add('hidden');
          callbackChips.classList.add('hidden');
          settingsContent.classList.add('hidden');
          dashboardContainer.classList.remove('hidden');
          updateDashboard();
        } else {
          searchBar.classList.remove('hidden');
          cardsContainer.classList.remove('hidden');
          settingsContent.classList.add('hidden');
          dashboardContainer.classList.add('hidden');

          if (tab === 'contacted') {
            doneChips.classList.remove('hidden');
            callbackChips.classList.add('hidden');
          } else if (tab === 'callback') {
            callbackChips.classList.remove('hidden');
            doneChips.classList.add('hidden');
          } else {
            doneChips.classList.add('hidden');
            callbackChips.classList.add('hidden');
            currentDoneFilter = 'all';
            currentCallbackFilter = 'all';
          }

          renderCards();
        }
      }

      function updateSettingsStats() {
        const all = data.length;
        const pending = data.filter(item => {
          if (!item.leadId) item.leadId = getOrCreateLeadId(item);
          return getDisposition(item.leadId).status === 'pending';
        }).length;
        const contacted = data.filter(item => {
          if (!item.leadId) item.leadId = getOrCreateLeadId(item);
          const status = getDisposition(item.leadId).status;
          return status !== 'pending' && status !== 'callback';
        }).length;
        const callback = data.filter(item => {
          if (!item.leadId) item.leadId = getOrCreateLeadId(item);
          return getDisposition(item.leadId).status === 'callback';
        }).length;

        document.getElementById('stat-total').textContent = all;
        document.getElementById('stat-contacted').textContent = contacted;
        document.getElementById('stat-pending').textContent = pending;
        document.getElementById('stat-callback').textContent = callback;
      }

      function setDoneFilter(filter) {
        currentDoneFilter = filter;

        document.querySelectorAll('.chip-filter').forEach(chip => {
          chip.classList.remove('chip-active');
        });

        document.getElementById(`chip-${filter}`).classList.add('chip-active');

        renderCards();
      }

      function setCallbackFilter(filter) {
        currentCallbackFilter = filter;

        document.querySelectorAll('.callback-chip-filter').forEach(chip => {
          chip.classList.remove('callback-chip-active');
        });

        document.getElementById(`callback-chip-${filter}`).classList.add('callback-chip-active');

        renderCards();
      }

      function updateCounts() {
        const all = data.length;
        const pending = data.filter(item => {
          if (!item.leadId) item.leadId = getOrCreateLeadId(item);
          return getDisposition(item.leadId).status === 'pending';
        }).length;
        const contacted = data.filter(item => {
          if (!item.leadId) item.leadId = getOrCreateLeadId(item);
          const status = getDisposition(item.leadId).status;
          return status !== 'pending' && status !== 'callback';
        }).length;
        const callback = data.filter(item => {
          if (!item.leadId) item.leadId = getOrCreateLeadId(item);
          return getDisposition(item.leadId).status === 'callback';
        }).length;

        document.getElementById('count-all').textContent = all;
        document.getElementById('count-pending').textContent = pending;
        document.getElementById('count-contacted').textContent = contacted;
        document.getElementById('count-callback').textContent = callback;
      }

      // Compute dashboard metrics from current data and dispositions (modern)
      function computeDashboardMetrics() {
        const metrics = {
          totalCustomers: data.length,
          totalCalls: 0,
          idleTimeMinutes: 0,
          callsLastHour: 0,
          pendingCount: 0,
          wrongNumberCount: 0,
          notReachableCount: 0,
          upcomingCallbacks: 0,
          overdueCallbacks: 0,
          dispositions: {},
          customersByCategory: {},
          customersBySubcategory: {},
          categoryBreakdown: {
            interested: 0,
            not_interested: 0,
            callback: 0,
            wrong_number: 0,
            not_reachable: 0,
            already_renewed: 0,
            will_think: 0,
            pending: 0
          },
          last5Contacts: []
        };

        const now = Date.now();
        let latestContactTs = 0;
        const allHistoryEntries = [];
        const sevenDaysAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;

        function getSubcategory(item) {
          if (item.plan_name) return item.plan_name;
          if (item.plan) return item.plan;
          if (item.mainCustomFields) {
            for (const k of Object.keys(item.mainCustomFields)) {
              if (/plan|package|product/i.test(k)) return item.mainCustomFields[k];
            }
          }
          return 'Unknown';
        }

        data.forEach(item => {
          const disp = getDisposition(item.leadId);
          const status = disp.status || 'pending';
          metrics.dispositions[status] = (metrics.dispositions[status] || 0) + 1;
          metrics.categoryBreakdown[status] = (metrics.categoryBreakdown[status] || 0) + 1;

          // Count wrong numbers and not reachable
          if (status === 'wrong_number') metrics.wrongNumberCount++;
          if (status === 'not_reachable') metrics.notReachableCount++;
          if (status === 'pending') metrics.pendingCount++;
          
          if (Array.isArray(disp.history)) {
            disp.history.forEach(h => {
              const ts = h.timestamp ? new Date(h.timestamp).getTime() : 0;
              allHistoryEntries.push({ ts, leadId: item.leadId, name: item.name, phone: item.phone, status: h.status, notes: h.notes });
              if (ts > latestContactTs) latestContactTs = ts;
              
              // Calls in last hour
              if (ts >= now - 60 * 60 * 1000) {
                metrics.callsLastHour++;
              }
            });
            metrics.totalCalls += disp.history.length;

            // Track callbacks
            if (status === 'callback' && disp.callback) {
              const callbackTime = new Date(disp.callback).getTime();
              if (callbackTime > now) {
                metrics.upcomingCallbacks++;
              } else {
                metrics.overdueCallbacks++;
              }
            }
          }

          // Keep category and subcategory tracking for backwards compatibility
          const company = (item.company || 'Unknown').toString();
          metrics.customersByCategory[company] = (metrics.customersByCategory[company] || 0) + 1;

          const sub = getSubcategory(item) || 'Unknown';
          metrics.customersBySubcategory[sub] = (metrics.customersBySubcategory[sub] || 0) + 1;
        });

        // last 5 contacts
allHistoryEntries.sort((a, b) => b.ts - a.ts);

metrics.last5Contacts = allHistoryEntries.slice(0, 5).map(e => ({
  name: e.name,
  phone: e.phone,
  time: e.ts
    ? new Date(e.ts).toLocaleString('en-IN', {
        day: '2-digit',
        month: 'short',
        hour: '2-digit',
        minute: '2-digit',
      })
    : 'N/A',
  status: e.status,
  notes: e.notes,
}));

if (latestContactTs > 0) {
  metrics.lastContactConnected = new Date(latestContactTs).toLocaleString(
    'en-IN',
    { day: '2-digit', month: 'short', hour: '2-digit', minute: '2-digit' }
  );

  // Calculate idle time in minutes
  const idleMinutes = Math.round((now - latestContactTs) / 60000);
  const hr = Math.floor(idleMinutes / 60);
  const min = idleMinutes % 60;

  // Format as "1 hr 2 min" or "45 min"
  if (hr > 0) {
    metrics.idleTimeMinutes = `${hr} hr${hr > 1 ? 's' : ''} ${min}`;
  } else {
    metrics.idleTimeMinutes = `${min}`;
  }
} else {
  metrics.lastContactConnected = null;
  metrics.idleTimeMinutes = '0 min';
}

return metrics;
      }

      // Render/update dashboard into #dashboardContainer (modern purple style)
      function updateDashboard() {
        const container = document.getElementById('dashboardContainer');
        if (!container) return;
        const m = computeDashboardMetrics();

        const dateStr = new Date().toLocaleDateString('en-IN', { weekday: 'short', day: '2-digit', month: 'short' });

        const headerCard = `
          <div class="col-span-1 sm:col-span-3 lg:col-span-4 bg-gradient-to-r from-purple-600 to-purple-500 text-white rounded-2xl p-5 shadow-lg">
            <div class="flex items-start justify-between">
              <div>
                <div class="text-xs opacity-80">Today's Date</div>
                <div class="text-xl font-bold mt-1">${dateStr}</div>
                <div class="text-sm opacity-80 mt-2">Total Customers: <span class="font-semibold">${m.totalCustomers}</span></div>
              </div>
              <div class="flex flex-col items-end">
                <div class="w-12 h-12 bg-white bg-opacity-20 rounded-xl flex items-center justify-center">
                  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-calendar h-5 w-5 md:h-6 md:w-6 text-white"><path d="M8 2v4"></path><path d="M16 2v4"></path><rect width="18" height="18" x="3" y="4" rx="2"></rect><path d="M3 10h18"></path></svg>
                  </div>
              </div>
            </div>
            <div class="mt-4">
              <div class="text-sm opacity-90">Quick Summary</div>
              <div class="mt-2 grid grid-cols-2 gap-2">
                <div class="bg-white bg-opacity-10 rounded-lg p-3">
                  <div class="text-xs opacity-80">Total Calls</div>
                  <div class="text-lg font-semibold">${m.totalCalls}</div>
                </div>
                <div class="bg-white bg-opacity-10 rounded-lg p-3">
                  <div class="text-xs opacity-80">Idle Time</div>
                  <div class="text-lg font-semibold">${m.idleTimeMinutes} min</div>
                </div>
              </div>
            </div>
          </div>
        `;

        const smallCards = `
          <div class="col-span-1 sm:col-span-1 lg:col-span-2 grid grid-cols-2 gap-3">
            <div class="bg-white rounded-xl p-4 shadow-sm">
              <div class="text-xs text-gray-500">Last Hour</div>
              <div class="text-2xl font-bold text-gray-800">${m.callsLastHour}</div>
            </div>
            <div class="bg-white rounded-xl p-4 shadow-sm">
              <div class="text-xs text-gray-500">Pending</div>
              <div class="text-2xl font-bold text-gray-800">${m.pendingCount}</div>
            </div>
            <div class="bg-white rounded-xl p-4 shadow-sm">
              <div class="text-xs text-gray-500">Overdue</div>
              <div class="text-2xl font-bold text-gray-800">${m.overdueCallbacks}</div>
            </div>
            <div class="bg-white rounded-xl p-4 shadow-sm">
              <div class="text-xs text-gray-500">Upcoming</div>
              <div class="text-2xl font-bold text-gray-800">${m.upcomingCallbacks}</div>
            </div>
          </div>
        `;

        // Categories visual
        const cats = m.categoryBreakdown;
        const total = m.totalCustomers || 1;
        const catsRows = Object.entries(cats)
          .filter(([k,v]) => k !== 'pending') // Exclude pending since we show it separately
          .map(([k,v]) => {
            const label = k.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
            const icon = {
              'interested': '‚úÖ',
              'not_interested': '‚ùå',
              'callback': 'üìû',
              'wrong_number': 'üö´',
              'not_reachable': 'üìµ',
              'already_renewed': '‚úîÔ∏è',
              'will_think': 'ü§î'
            }[k] || '';
            return `
              <div class="flex items-center justify-between">
                <div class="text-sm text-gray-700">${icon} ${escapeHtml(label)}</div>
                <div class="font-semibold text-gray-800">${v}</div>
              </div>
              <div class="w-full bg-gray-100 h-2 rounded mt-1 mb-3">
                <div class="bg-purple-500 h-2 rounded" style="width:${Math.round((v/total)*100)}%"></div>
              </div>`;
          }).join('');

        const catsHtml = `
          <div class="col-span-1 sm:col-span-1 lg:col-span-2 bg-white rounded-xl p-4 shadow-sm">
            <div class="text-xs text-gray-500">Customer Categories</div>
            <div class="mt-3">${catsRows}</div>
          </div>
        `;

        // Last 5 contacts - improved formatting
        const last5Rows = m.last5Contacts.map((c, i) => `
          <tr class="${i % 2 === 0 ? 'bg-gray-50' : 'bg-white'} hover:bg-blue-50 transition">
            <td class="p-2 text-xs font-medium text-gray-700 rounded-l-lg">${escapeHtml(c.name)}</td>
            <td class="p-2 text-xs text-gray-500">${escapeHtml(c.phone)}</td>
            <td class="p-2 text-xs text-gray-500">${escapeHtml(c.time)}</td>
            <td class="p-2 text-xs text-gray-600 rounded-r-lg">${escapeHtml(c.status)}</td>
          </tr>
        `).join('');
        const last5Html = `
          <div class="col-span-1 sm:col-span-3 lg:col-span-6 bg-white rounded-xl p-4 shadow-sm">
            <div class="text-sm font-semibold text-gray-800 mb-2">Last 5 Contacts</div>
            <div class="mt-2 overflow-x-auto">
              <table class="w-full text-xs border-separate border-spacing-0 rounded-lg">
                <thead>
                  <tr class="bg-gray-100 text-gray-500">
                    <th class="p-2 rounded-tl-lg font-semibold">Name</th>
                    <th class="p-2 font-semibold">Phone</th>
                    <th class="p-2 font-semibold">Time</th>
                    <th class="p-2 rounded-tr-lg font-semibold">Status</th>
                  </tr>
                </thead>
                <tbody>${last5Rows}</tbody>
              </table>
            </div>
          </div>
        `;

        container.innerHTML = `<div class="grid grid-cols-1 sm:grid-cols-3 lg:grid-cols-6 gap-3">${headerCard}${smallCards}${catsHtml}</div>${last5Html}`;
      }

      function openModal(leadId) {
        if (!requireAuth()) return;

        currentLeadId = leadId;
        const item = data.find(d => d.leadId === leadId);
        const disp = getDisposition(leadId);

        document.getElementById('modalCustomerInfo').innerHTML = `
        <div class="font-bold text-gray-800 text-base">${item.name}</div>
        <div class="text-xs text-gray-500 mt-1 font-light">Lead ID: ${item.leadId}</div>
      `;

        document.getElementById('dispositionSelect').value = disp.status === 'pending' ? '' : disp.status;
        document.getElementById('dispositionNotes').value = disp.notes || '';
        document.getElementById('callbackDateTime').value = disp.callback || '';

        renderHistory(disp.history || []);

        document.getElementById('dispositionModal').classList.add('active');

        if (disp.status === 'callback') {
          document.getElementById('callbackSection').style.display = 'block';
        }
      }

      function closeModal() {
        document.getElementById('dispositionModal').classList.remove('active');
        currentLeadId = null;
      }

      async function saveDisposition() {
        if (!requireAuth()) return;
        if (!currentLeadId) return;

        const status = document.getElementById('dispositionSelect').value;
        const notes = document.getElementById('dispositionNotes').value;
        const callback = document.getElementById('callbackDateTime').value;

        if (!status) {
          alert('Please select a disposition');
          return;
        }

        const disp = getDisposition(currentLeadId);
        disp.status = status;
        disp.notes = notes;
        disp.callback = status === 'callback' ? callback : null;
        disp.lastUpdated = new Date().toISOString();

        if (!disp.history) disp.history = [];
        const entry = {
          status,
          notes,
          callback: disp.callback || null,
          timestamp: new Date().toISOString()
        };
        disp.history.push(entry);

        await setDisposition(currentLeadId, disp);
        renderHistory(disp.history);
        closeModal();
      }

      function renderHistory(history) {
        const el = document.getElementById('dispositionHistory');
        if (!el) return;
        if (!history || history.length === 0) {
          el.innerHTML = '<div class="text-gray-400">No history yet</div>';
          return;
        }

        const list = history.slice().reverse().map(h => {
          const dt = new Date(h.timestamp);
          const dateStr = dt.toLocaleDateString('en-IN', { day: '2-digit', month: 'short', year: 'numeric' });
          const timeStr = dt.toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit' });
          const statusLabel = h.status ? h.status.replace(/_/g, ' ') : 'pending';
          const notes = h.notes ? `<div class="text-gray-700 mt-1">${escapeHtml(h.notes)}</div>` : '';
          const cb = h.callback ? `<div class="text-xs text-yellow-700 mt-1">Callback: ${new Date(h.callback).toLocaleString('en-IN', { day: '2-digit', month: 'short', hour: '2-digit', minute: '2-digit' })}</div>` : '';
          return `
          <div class="border-b border-gray-100 py-2">
            <div class="flex items-center justify-between">
              <div class="font-medium text-gray-700 text-sm">${escapeHtml(statusLabel)}</div>
              <div class="text-xs text-gray-400">${dateStr} ${timeStr}</div>
            </div>
            ${notes}
            ${cb}
          </div>
        `;
        }).join('');

        el.innerHTML = list;
      }

      function escapeHtml(str) {
        if (!str) return '';
        return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
      }

      document.getElementById('dispositionSelect').addEventListener('change', (e) => {
        const section = document.getElementById('callbackSection');
        section.style.display = e.target.value === 'callback' ? 'block' : 'none';
      });

      document.getElementById('searchInput').addEventListener('input', renderCards);

      function downloadSampleTemplate() {
        const headers = ['proposer', 'phone', 'plan_name', 'renewal_date', 'total_sum_insured', 'total_premium', 'proposed_addon_cost', 'ages'];
        const sampleData = [
          ['Boya Tribhuvan Teja', '9885562055', 'Care Supreme', '11-Oct-2025', '‚Çπ17,50,000', '7562', '645', '32'],
          ['Gurparshad Singh', '9501242244', 'Care Supreme', '12-Oct-2025', '‚Çπ15,00,000', '46627', '2151', '47, 44, 18, 14'],
          ['Boya Varalakshmi Dev', '9885562055', 'Care Supreme', '13-Oct-2025', '‚Çπ17,50,000', '105604', '2796', '65']
        ];

        const rows = [headers, ...sampleData];
        const csvContent = rows.map(row => row.join(',')).join('\n');

        const blob = new Blob(['\uFEFF' + csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        if (link.download !== undefined) {
          const url = URL.createObjectURL(blob);
          link.setAttribute('href', url);
          link.setAttribute('download', 'Insurance_CRM_Import_Template.csv');
          link.style.visibility = 'hidden';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }

        alert('‚úÖ Template downloaded!\n\nUse these exact column headers:\n‚Ä¢ proposer\n‚Ä¢ phone\n‚Ä¢ plan_name\n‚Ä¢ renewal_date\n‚Ä¢ total_sum_insured\n‚Ä¢ total_premium\n‚Ä¢ proposed_addon_cost\n‚Ä¢ ages');
      }

      // Field mapping modal HTML
      const mappingModalHtml = `
      <div id="mappingModal" class="modal">
        <div class="modal-content bg-white rounded-3xl shadow-2xl mx-2 sm:mx-4 w-full max-w-2xl max-h-[95vh] overflow-y-auto">
          <div class="sticky top-0 bg-white rounded-t-3xl px-4 sm:px-6 py-4 sm:py-5 flex justify-between items-center border-b border-gray-100 z-10">
            <h3 class="text-base sm:text-lg font-bold text-gray-800">Map CSV Fields</h3>
            <button onclick="document.getElementById('mappingModal').classList.remove('active')" class="w-10 h-10 sm:w-8 sm:h-8 flex items-center justify-center rounded-full hover:bg-gray-100 text-gray-400 hover:text-gray-600 text-xl sm:text-2xl transition-all">√ó</button>
          </div>
          
          <div class="p-4 sm:p-6 space-y-4 sm:space-y-5">
            <div class="bg-blue-50 p-3 sm:p-4 rounded-xl text-xs sm:text-sm text-blue-700">
              Please map your CSV columns to the required fields below. Select the appropriate column for each field.
            </div>
            
            <div class="grid gap-3 sm:gap-4" id="mappingFields">
              <div class="bg-gray-50 p-3 sm:p-4 rounded-xl">
                <h4 class="font-semibold text-gray-800 mb-3 text-sm sm:text-base">Required Fields</h4>
                <div class="space-y-3 sm:space-y-4">
                  <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
                    <div class="space-y-2">
                      <label class="block text-xs sm:text-sm font-medium text-gray-600">Name</label>
                      <div class="flex gap-2 items-center">
                        <select id="map_name" class="flex-1 px-3 py-2.5 sm:py-2 bg-white border border-gray-200 rounded-lg text-xs sm:text-sm max-h-40 overflow-y-auto min-h-[44px]"></select>
                        <button onclick="addMappingField('name')" class="px-3 py-2.5 sm:py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-all text-xs sm:text-sm min-w-[44px] min-h-[44px] sm:min-w-0 sm:min-h-0">+</button>
                      </div>
                      <div class="flex items-center gap-2">
                        <input type="checkbox" id="show_name_main" class="ml-1" checked disabled title="Name always shown" />
                        <label for="show_name_main" class="text-xs text-gray-500">Show</label>
                      </div>
                      <div id="name_fields"></div>
                    </div>
                    <div class="space-y-2">
                      <label class="block text-xs sm:text-sm font-medium text-gray-600">Phone</label>
                      <div class="flex gap-2 items-center">
                        <select id="map_phone" class="flex-1 px-3 py-2.5 sm:py-2 bg-white border border-gray-200 rounded-lg text-xs sm:text-sm max-h-40 overflow-y-auto min-h-[44px]"></select>
                        <button onclick="addMappingField('phone')" class="px-3 py-2.5 sm:py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-all text-xs sm:text-sm min-w-[44px] min-h-[44px] sm:min-w-0 sm:min-h-0">+</button>
                      </div>
                      <div class="flex items-center gap-2">
                        <input type="checkbox" id="show_phone_main" class="ml-1" checked disabled title="Phone always shown" />
                        <label for="show_phone_main" class="text-xs text-gray-500">Show</label>
                      </div>
                      <div id="phone_fields"></div>
                    </div>
                  </div>
                  <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
                    <div class="space-y-2">
                      <label class="block text-xs sm:text-sm font-medium text-gray-600">Sum Insured</label>
                      <div class="flex gap-2 items-center">
                        <select id="map_sum_insured" class="flex-1 px-3 py-2.5 sm:py-2 bg-white border border-gray-200 rounded-lg text-xs sm:text-sm max-h-40 overflow-y-auto min-h-[44px]"></select>
                        <button onclick="addMappingField('sum_insured')" class="px-3 py-2.5 sm:py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-all text-xs sm:text-sm min-w-[44px] min-h-[44px] sm:min-w-0 sm:min-h-0">+</button>
                      </div>
                      <div class="flex items-center gap-2">
                        <input type="checkbox" id="show_sum_insured_main" class="ml-1" checked />
                        <label for="show_sum_insured_main" class="text-xs text-gray-500">Show</label>
                      </div>
                      <div id="sum_insured_fields"></div>
                    </div>
                    <div class="space-y-2">
                      <label class="block text-xs sm:text-sm font-medium text-gray-600">Premium</label>
                      <div class="flex gap-2 items-center">
                        <select id="map_premium" class="flex-1 px-3 py-2.5 sm:py-2 bg-white border border-gray-200 rounded-lg text-xs sm:text-sm max-h-40 overflow-y-auto min-h-[44px]"></select>
                        <button onclick="addMappingField('premium')" class="px-3 py-2.5 sm:py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-all text-xs sm:text-sm min-w-[44px] min-h-[44px] sm:min-w-0 sm:min-h-0">+</button>
                      </div>
                      <div class="flex items-center gap-2">
                        <input type="checkbox" id="show_premium_main" class="ml-1" checked />
                        <label for="show_premium_main" class="text-xs text-gray-500">Show</label>
                      </div>
                      <div id="premium_fields"></div>
                    </div>
                  </div>
                  <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
                    <div class="space-y-2">
                      <label class="block text-xs sm:text-sm font-medium text-gray-600">Company</label>
                      <div class="flex gap-2 items-center">
                        <select id="map_company" class="flex-1 px-3 py-2.5 sm:py-2 bg-white border border-gray-200 rounded-lg text-xs sm:text-sm max-h-40 overflow-y-auto min-h-[44px]"></select>
                        <button onclick="addMappingField('company')" class="px-3 py-2.5 sm:py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-all text-xs sm:text-sm min-w-[44px] min-h-[44px] sm:min-w-0 sm:min-h-0">+</button>
                      </div>
                      <div class="flex items-center gap-2">
                        <input type="checkbox" id="show_company_main" class="ml-1" checked />
                        <label for="show_company_main" class="text-xs text-gray-500">Show</label>
                      </div>
                      <div id="company_fields"></div>
                    </div>
                    <div class="space-y-2">
                      <!-- Empty div to maintain grid layout -->
                    </div>
                  </div>
                  <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
                    <div class="space-y-2">
                      <label class="block text-xs sm:text-sm font-medium text-gray-600">Expiry Date</label>
                      <div class="flex gap-2 items-center">
                        <select id="map_expiry_date" class="flex-1 px-3 py-2.5 sm:py-2 bg-white border border-gray-200 rounded-lg text-xs sm:text-sm max-h-40 overflow-y-auto min-h-[44px]"></select>
                        <button onclick="addMappingField('expiry_date')" class="px-3 py-2.5 sm:py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-all text-xs sm:text-sm min-w-[44px] min-h-[44px] sm:min-w-0 sm:min-h-0">+</button>
                      </div>
                      <div class="flex items-center gap-2">
                        <input type="checkbox" id="show_expiry_date_main" class="ml-1" checked disabled title="Expiry always shown" />
                        <label for="show_expiry_date_main" class="text-xs text-gray-500">Show</label>
                      </div>
                      <div id="expiry_date_fields"></div>
                    </div>
                    <div class="space-y-2">
                      <!-- Empty div to maintain grid layout -->
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="bg-gray-50 p-3 sm:p-4 rounded-xl">
                <h4 class="font-semibold text-gray-800 mb-3 text-sm sm:text-base">Customer Details (Optional)</h4>
                <div class="space-y-3" id="additionalFieldsMapping"></div>
                <button onclick="addCustomField()" class="mt-3 text-xs sm:text-sm text-blue-600 hover:text-blue-700 flex items-center gap-1 py-2 px-3 rounded-lg hover:bg-blue-50 transition-all min-h-[44px]">
                  <span class="text-base sm:text-lg">+</span> Add Custom Field
                </button>
              </div>
            </div>

            <button onclick="processMappedFields()" class="w-full btn-primary text-white font-semibold py-3.5 sm:py-4 rounded-xl text-sm sm:text-base min-h-[48px]">
              Import Data
            </button>
          </div>
        </div>
      </div>
    `;

      // Add mapping modal to body if not exists
      if (!document.getElementById('mappingModal')) {
        document.body.insertAdjacentHTML('beforeend', mappingModalHtml);
      }

      // CSV import related variables and functions
      // Global variables used by PapaParse handler and mapping UI
      let csvData = null;
      let csvHeaders = null;
      let additionalFields = [];
      let selectedOptions = new Set();
      let fieldMappings = {
        name: [],
        phone: [],
        sum_insured: [],
        premium: [],
        expiry_date: [],
        company: []
      };

      // Function to update available options in all selects
      function updateAvailableOptions() {
        window.updateAvailableOptions = updateAvailableOptions;
        // Build a normalized set of currently selected header keys (trimmed lowercase)
        selectedOptions.clear();
        const normalize = s => (s || '').toString().trim().toLowerCase();

        const selects = ['map_name', 'map_phone', 'map_sum_insured', 'map_premium', 'map_expiry_date', 'map_company'];
        selects.forEach(selectId => {
          const select = document.getElementById(selectId);
          if (select && select.value) selectedOptions.add(normalize(select.value));
        });

        // Additional mappings (dynamically added mapping selects)
        Object.values(fieldMappings).flat().forEach(mappingId => {
          const select = document.getElementById(mappingId);
          if (select && select.value) selectedOptions.add(normalize(select.value));
        });

        // Custom fields selects
        additionalFields.forEach(fieldId => {
          const select = document.getElementById(`${fieldId}_column`);
          if (select && select.value) selectedOptions.add(normalize(select.value));
        });

        // Update options in a given select element
        function updateSelectOptions(select) {
          const currentValue = select.value;
          const currentNorm = normalize(currentValue);
          const options = ['<option value="">Select Column</option>'];

          if (csvHeaders) {
            csvHeaders.forEach(header => {
              const hNorm = normalize(header);
              // include header if not chosen elsewhere OR it's the current value for this select
              if (!selectedOptions.has(hNorm) || hNorm === currentNorm) {
                options.push(`<option value="${header}">${header}</option>`);
              }
            });
          }

          select.innerHTML = options.join('');
          // Restore previously selected value if still present
          try { select.value = currentValue; } catch (e) { /* ignore */ }
        }

        // Update main selects
        selects.forEach(selectId => {
          const select = document.getElementById(selectId);
          if (select) {
            updateSelectOptions(select);
          }
        });

        // Update additional field selects
        Object.values(fieldMappings).flat().forEach(mappingId => {
          const select = document.getElementById(mappingId);
          if (select) {
            updateSelectOptions(select);
          }
        });

        // Update custom field selects
        additionalFields.forEach(fieldId => {
          const select = document.getElementById(`${fieldId}_column`);
          if (select) {
            updateSelectOptions(select);
          }
        });
      }

      window.addMappingField = function (fieldType) {
        const container = document.getElementById(`${fieldType}_fields`) || document.getElementById(`map_${fieldType}`).parentElement;
        const mappingId = `${fieldType}_${Date.now()}`;

        const select = document.createElement('div');
        select.className = 'flex gap-2 mb-2';
        select.innerHTML = `
          <select id="${mappingId}" class="flex-1 px-3 py-2.5 sm:py-2 bg-white border border-gray-200 rounded-lg text-xs sm:text-sm min-h-[44px]" onchange="updateAvailableOptions()">
            <option value="">Select Column</option>
            ${csvHeaders ? csvHeaders.filter(h => !selectedOptions.has(h)).map(h => `<option value="${h}">${h}</option>`).join('') : ''}
          </select>
          <button onclick="removeMappingField('${mappingId}')" class="px-3 py-2.5 sm:py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-all text-xs sm:text-sm min-w-[44px] min-h-[44px] sm:min-w-0 sm:min-h-0">
            √ó
          </button>
        `;

        if (container.tagName === 'DIV') {
          container.appendChild(select);
        } else {
          const parentDiv = document.createElement('div');
          parentDiv.id = `${fieldType}_fields`;
          parentDiv.className = 'space-y-2';

          // Move the original select into the new container
          const originalContent = container.innerHTML;
          container.innerHTML = '';
          parentDiv.innerHTML = `<div class="flex gap-2 mb-2">${originalContent}</div>`;
          parentDiv.appendChild(select);

          container.parentElement.appendChild(parentDiv);
        }

        // Add to field mappings
        if (!fieldMappings[fieldType]) {
          fieldMappings[fieldType] = [];
        }
        fieldMappings[fieldType].push(mappingId);
      };

      window.removeMappingField = function (mappingId) {
        const element = document.getElementById(mappingId);
        const selectedValue = element?.value;

        if (element && element.parentElement) {
          element.parentElement.remove();
        }

        // Remove from field mappings
        for (const [fieldType, mappings] of Object.entries(fieldMappings)) {
          const index = mappings.indexOf(mappingId);
          if (index !== -1) {
            mappings.splice(index, 1);
            break;
          }
        }

        // Update available options after removing a field
        updateAvailableOptions();
      };

      window.addCustomField = function () {
        const container = document.getElementById('additionalFieldsMapping');
        const fieldId = 'custom_' + Date.now();

        // Filter out already selected options
        const availableHeaders = csvHeaders ? csvHeaders.filter(h => !selectedOptions.has(h)) : [];

        const fieldHtml = `
          <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 items-start sm:items-center space-y-2 sm:space-y-0" id="${fieldId}_container">
            <div class="space-y-1">
              <input type="text" placeholder="Field Label" class="w-full px-3 py-2.5 sm:py-2 bg-white border border-gray-200 rounded-lg text-xs sm:text-sm min-h-[44px]" 
                id="${fieldId}_label">
            </div>
            <div class="space-y-2">
              <div class="flex gap-2 items-center">
                <select class="flex-1 px-3 py-2.5 sm:py-2 bg-white border border-gray-200 rounded-lg text-xs sm:text-sm min-h-[44px]" 
                        id="${fieldId}_column" 
                        onchange="updateAvailableOptions(); updateCustomFieldLabel('${fieldId}')">
                  <option value="">Select Column</option>
                  ${availableHeaders.map(h => `<option value="${h}">${h}</option>`).join('')}
                </select>
                <button onclick="removeCustomField('${fieldId}')" 
                  class="px-3 py-2.5 sm:py-2 text-red-500 hover:bg-red-50 rounded-lg text-xs sm:text-sm min-w-[44px] min-h-[44px] sm:min-w-0 sm:min-h-0">√ó</button>
              </div>
              <div class="flex items-center gap-2">
                <input type="checkbox" id="show_custom_main_${fieldId}" class="ml-1" />
                <label for="show_custom_main_${fieldId}" class="text-xs text-gray-500">Show</label>
              </div>
            </div>
          </div>
        `;

        container.insertAdjacentHTML('beforeend', fieldHtml);
        additionalFields.push(fieldId);

        // Add this field's select to the tracking
        fieldMappings['custom'] = fieldMappings['custom'] || [];
        fieldMappings['custom'].push(`${fieldId}_column`);
      };

      window.updateCustomFieldLabel = function (fieldId) {
        const selectElement = document.getElementById(`${fieldId}_column`);
        const labelElement = document.getElementById(`${fieldId}_label`);

        if (selectElement && labelElement) {
          const selectedValue = selectElement.value;
          if (selectedValue) {
            // Update the label field with the selected column name
            labelElement.value = selectedValue;
          }
        }
      };

      window.removeCustomField = function (fieldId) {
        const container = document.getElementById(`${fieldId}_container`);
        const select = document.getElementById(`${fieldId}_column`);

        // Remove from fieldMappings
        if (fieldMappings['custom']) {
          const index = fieldMappings['custom'].indexOf(`${fieldId}_column`);
          if (index !== -1) {
            fieldMappings['custom'].splice(index, 1);
          }
        }

        // Remove from additionalFields
        const addIndex = additionalFields.indexOf(fieldId);
        if (addIndex !== -1) {
          additionalFields.splice(addIndex, 1);
        }

        // Remove the container
        if (container) {
          container.remove();
        }

        // Update available options
        updateAvailableOptions();
      };

      window.processMappedFields = async function () {
          // Get values from all mapped fields
          const mapping = {};
          const multiMapping = {};

          for (const [fieldType, mappingIds] of Object.entries(fieldMappings)) {
            const mainEl = document.getElementById(`map_${fieldType}`);
            const mainValue = mainEl ? mainEl.value : '';
            if (!mainValue) {
              const additionalValues = mappingIds
                .map(id => {
                  const el = document.getElementById(id);
                  return el ? el.value : '';
                })
                .filter(Boolean);

              if (additionalValues.length === 0) {
                mapping[fieldType] = '';
              } else {
                mapping[fieldType] = additionalValues[0];
                if (additionalValues.length > 1) {
                  multiMapping[fieldType] = additionalValues.slice(1);
                }
              }
            } else {
              mapping[fieldType] = mainValue;
              const additionalValues = mappingIds
                .map(id => {
                  const el = document.getElementById(id);
                  return el ? el.value : '';
                })
                .filter(Boolean);
              if (additionalValues.length > 0) {
                multiMapping[fieldType] = additionalValues;
              }
            }
          }

          // Validate required fields
          const missingFields = [];
          for (const [field, value] of Object.entries(mapping)) {
            if (!value) missingFields.push(field.replace('_', ' '));
          }

          if (missingFields.length > 0) {
            alert(`‚ùå Please map all required fields:\n\n${missingFields.join('\n')}`);
            return;
          }

          // Get additional field mappings
          const additionalMappings = {};
          additionalFields.forEach(fieldId => {
            const labelEl = document.getElementById(`${fieldId}_label`);
            const columnEl = document.getElementById(`${fieldId}_column`);
            if (labelEl && columnEl && labelEl.value && columnEl.value) {
              additionalMappings[labelEl.value] = columnEl.value;
            }
          });

          // Process the CSV data with mappings
          const newData = [];
          let errorCount = 0;

          for (let i = 0; i < csvData.length; i++) {
            const row = csvData[i];
            if (!row || Object.keys(row).length === 0) continue;

            try {
              // Use only user-selected columns for required fields
              const name = row[mapping.name] || '';
              const phone = (row[mapping.phone] || '').replace(/[^0-9]/g, '');
              const expiryDate = row[mapping.expiry_date] || '';
              const sumInsured = row[mapping.sum_insured] || '';
              const premiumRaw = row[mapping.premium] || '';
              const premium = parseInt(premiumRaw.replace(/[^0-9]/g, '')) || 0;
              const company = row[mapping.company] || '';

              // Skip if essential data is missing
              if (!name || !phone) {
                errorCount++;
                continue;
              }

              // Build mainFields and customerDetails based on checkboxes
              const mainFields = {
                sumInsured: document.getElementById('show_sum_insured_main')?.checked ? sumInsured : null,
                premium: document.getElementById('show_premium_main')?.checked ? premium : null,
                company: document.getElementById('show_company_main')?.checked ? company : null,
              };

              // Custom fields - include Required Fields that are checked
              const mainCustomFields = {};
              const customerDetailsArr = [];

              // Add Required Fields to mainCustomFields if checked
              if (sumInsured) {
                if (document.getElementById('show_sum_insured_main')?.checked) {
                  mainCustomFields['Sum Insured_checked'] = sumInsured;
                } else {
                  customerDetailsArr.push(`Sum Insured_unchecked: ${sumInsured}`);
                }
              }
              if (premium) {
                if (document.getElementById('show_premium_main')?.checked) {
                  mainCustomFields['Total Premium_checked'] = `‚Çπ${premium.toLocaleString("en-IN")}`;
                } else {
                  customerDetailsArr.push(`Total Premium_unchecked: ‚Çπ${premium.toLocaleString("en-IN")}`);
                }
              }
              if (company) {
                if (document.getElementById('show_company_main')?.checked) {
                  mainCustomFields['Company_checked'] = company;
                } else {
                  customerDetailsArr.push(`Company_unchecked: ${company}`);
                }
              }

              // Add all other columns as custom fields (not mapped to required fields)
              for (const key of Object.keys(row)) {
                if ([mapping.name, mapping.phone, mapping.expiry_date, mapping.sum_insured, mapping.premium, mapping.company].includes(key)) continue;
                const value = row[key];
                if (value) {
                  customerDetailsArr.push(`${key}_unchecked: ${value}`);
                }
              }

              // Format customer details with _checked suffix for checked fields
              let formattedCustomerDetails = '';
              Object.entries(mainCustomFields).forEach(([key, value]) => {
                if (value) {
                  const displayKey = key.endsWith('_checked') ? key.replace('_checked', '') : key;
                  formattedCustomerDetails += `${displayKey}_checked - ${value}\n`;
                }
              });
              if (customerDetailsArr.length > 0) {
                formattedCustomerDetails += customerDetailsArr.join('\n');
              }

              const item = {
                sno: newData.length + 1,
                leadId: generateLeadId(),
                name: name,
                phone: phone,
                date: expiryDate,
                sumInsured: mainFields.sumInsured,
                premium: mainFields.premium,
                company: mainFields.company,
                mainCustomFields,
                amount: premium,
                addonCost: 0,
                customerDetails: formattedCustomerDetails.trim(),
                utilities: '' // Will be populated when disposition is set
              };

              newData.push(item);
            } catch (err) {
              errorCount++;
              console.warn(`Error processing row ${i}:`, err);
            }
          }

          if (newData.length === 0) {
            alert('‚ùå No valid data found in CSV file');
            return;
          }

          // Check for duplicates and filter them out
          const existingLeadIds = new Set(data.map(item => item.leadId).filter(Boolean));
          const uniqueNewData = newData.filter(item => !existingLeadIds.has(item.leadId));
          const duplicateCount = newData.length - uniqueNewData.length;

          let confirmMsg = `Import ${uniqueNewData.length} new leads?\n\n`;
          confirmMsg += `üìä Current leads: ${data.length}\n`;
          confirmMsg += `‚ûï New leads to add: ${uniqueNewData.length}\n`;
          if (duplicateCount > 0) {
            confirmMsg += `‚ö†Ô∏è Duplicates skipped: ${duplicateCount}\n`;
          }
          if (errorCount > 0) {
            confirmMsg += `‚ùå Errors skipped: ${errorCount}\n`;
          }
          confirmMsg += `\n‚úÖ Existing data will remain unchanged.`;

          if (!confirm(confirmMsg)) {
            return;
          }

          // Append new data to existing data
          data.push(...uniqueNewData);
          await saveCustomerData(data);

          // Close mapping modal and refresh UI
          document.getElementById('mappingModal').classList.remove('active');
          renderCards();
          updateCounts();

          let successMsg = `‚úÖ Successfully imported ${uniqueNewData.length} new leads!\n\n`;
          successMsg += `üìä Total leads now: ${data.length}\n`;
          if (duplicateCount > 0) {
            successMsg += `‚ö†Ô∏è ${duplicateCount} duplicates were skipped.\n`;
          }
          if (errorCount > 0) {
            successMsg += `‚ùå ${errorCount} rows had errors and were skipped.\n`;
          }
          successMsg += `\n‚ú® Existing data preserved successfully.`;

          alert(successMsg);
        };

        // end processMappedFields

      function handleFileUpload(event) {
  const file = event.target.files[0];
  if (!file) return;

  try {
    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      encoding: "UTF-8",
      quoteChar: '"',
      escapeChar: '"',
      newline: "", // auto-detect
      complete: function (results) {
        try {
          const rows = results.data;
          if (rows.length === 0) {
            alert("‚ùå CSV file has no valid data rows");
            return;
          }

          // Extract headers (exactly as CSV defines them)
              csvHeaders = results.meta.fields || Object.keys(rows[0] || {});
          additionalFields = [];

          console.log("‚úÖ CSV Headers:", csvHeaders);
          console.log("‚úÖ Sample Row:", rows[0]);

          // Populate mapping dropdowns (as in your code)
          const selects = [
            "map_name",
            "map_phone",
            "map_sum_insured",
            "map_premium",
            "map_expiry_date",
            "map_company"
          ];

          selects.forEach(selectId => {
            const select = document.getElementById(selectId);
            if (select) {
              select.innerHTML =
                '<option value="">Select Column</option>' +
                csvHeaders
                  .map(h => `<option value="${h}">${h}</option>`)
                  .join("");
              // Add change event listener to update options everywhere after any change
              select.addEventListener('change', updateAvailableOptions);
            }
          });

          // Store parsed rows globally (if you‚Äôre using csvData elsewhere)
          csvData = rows.map(row => {
            // Preserve multiline and ‚Çπ symbols exactly as in file
            const cleaned = {};
            for (const key in row) {
              if (Object.hasOwn(row, key)) {
                const val = row[key];
                cleaned[key] =
                  typeof val === "string"
                    ? val.replace(/\r?\n/g, "\n").trim()
                    : val;
              }
            }
            return cleaned;
          });

          console.log("üßæ Cleaned CSV Data:", csvData);

          // Store parsed rows globally and show your mapping modal
          csvData = rows.map(row => {
            const cleaned = {};
            for (const key in row) {
              if (Object.hasOwn(row, key)) {
                const val = row[key];
                cleaned[key] = typeof val === "string" ? val.replace(/\r?\n/g, "\n").trim() : val;
              }
            }
            return cleaned;
          });

          // Log parsed CSV data to console
          console.log('CSV Preview:', csvData);


          // Add button to mapping modal to show CSV table in a separate modal
          const showTableBtnId = 'showCsvTableBtn';
          let showTableBtn = document.getElementById(showTableBtnId);
          if (!showTableBtn) {
            let modalContent = document.querySelector('#mappingModal .modal-content .p-4');
            if (!modalContent) {
              modalContent = document.querySelector('#mappingModal .modal-content [class*="p-4"]');
            }
            showTableBtn = document.createElement('button');
            showTableBtn.id = showTableBtnId;
            showTableBtn.className = 'mb-4 bg-blue-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-600 transition-all';
            showTableBtn.textContent = 'Show CSV Data';
            showTableBtn.onclick = function() {
              document.getElementById('csvTableModal').classList.add('active');
            };
            if (modalContent) {
              modalContent.insertAdjacentElement('afterbegin', showTableBtn);
            }
          }

          // Create CSV table modal if not exists
          if (!document.getElementById('csvTableModal')) {
            const modalDiv = document.createElement('div');
            modalDiv.id = 'csvTableModal';
            modalDiv.className = 'modal';
            modalDiv.innerHTML = `
              <div class="modal-content bg-white rounded-3xl shadow-2xl mx-2 sm:mx-4 w-full max-w-3xl max-h-[90vh] overflow-y-auto">
                <div class="sticky top-0 bg-white rounded-t-3xl px-4 sm:px-6 py-4 sm:py-5 flex justify-between items-center border-b border-gray-100">
                  <h3 class="text-base sm:text-lg font-bold text-gray-800">CSV Data Table</h3>
                  <button onclick="document.getElementById('csvTableModal').classList.remove('active')"
                    class="w-8 h-8 flex items-center justify-center rounded-full hover:bg-gray-100 text-gray-400 hover:text-gray-600 text-2xl transition-all">√ó</button>
                </div>
                <div id="csvTableModalBody" class="p-4 sm:p-6"></div>
              </div>
            `;
            document.body.appendChild(modalDiv);
          }

          // Build full CSV table HTML for modal
          let fullTableHtml = '<div class="bg-gray-50 rounded-xl p-3 mb-3 overflow-hidden" style="max-height: 70vh;"><div class="overflow-x-auto overflow-y-auto" style="scrollbar-width: none; -ms-overflow-style: none; max-height: inherit;"><div style="-webkit-overflow-scrolling: touch;">';
          if (csvHeaders && csvData && csvData.length > 0) {
            fullTableHtml += '<table class="min-w-full text-xs border border-gray-200 rounded-lg overflow-x-auto"><thead class="sticky top-0 bg-gray-100 z-10"><tr>';
            csvHeaders.forEach(h => {
              fullTableHtml += `<th class="border-b px-2 py-2 text-left font-medium">${h}</th>`;
            });
            fullTableHtml += '</tr></thead><tbody class="bg-white">';
            csvData.forEach(row => {
              fullTableHtml += '<tr>';
              csvHeaders.forEach(h => {
                fullTableHtml += `<td class="border-b px-2 py-1">${row[h] || ''}</td>`;
              });
              fullTableHtml += '</tr>';
            });
            fullTableHtml += '</tbody></table>';
            fullTableHtml += `</div></div><div class="text-gray-500 mt-2">Total rows: ${csvData.length}</div>`;
          } else {
            fullTableHtml += '<div class="text-gray-500">No data found in CSV.</div>';
          }
          fullTableHtml += '</div>';
          document.getElementById('csvTableModalBody').innerHTML = fullTableHtml;

          // Update selects and mapping options immediately to hide already-selected headers
          updateAvailableOptions();

          // Show mapping modal
          document.getElementById("mappingModal").classList.add("active");
        } catch (err) {
          alert("‚ùå Error processing CSV: " + err.message);
          console.error("Processing error:", err);
        }
      },
      error: function (err) {
        alert("‚ùå Error parsing CSV: " + err.message);
        console.error("PapaParse error:", err);
      }
    });
  } catch (error) {
    alert("‚ùå Error handling file: " + error.message);
    console.error("File handling error:", error);
  } finally {
    event.target.value = ""; // reset file input
  }
}


      // Handle OAuth callback
      async function handleOAuthCallback() {
        try {
          const { data, error } = await supabase.auth.getSession();

          if (error) {
            console.error('OAuth callback error:', error);
            return;
          }

          if (data.session) {
            const user = data.session.user;
            console.log('OAuth user authenticated:', user);

            // Set user data
            currentUser = user.email;
            currentUserId = user.id;
            isAuthenticated = true;

            // Create session data
            const sessionData = {
              user: user.email,
              userId: user.id,
              loginTime: new Date().getTime(),
              expiresAt: new Date().getTime() + (24 * 60 * 60 * 1000),
              provider: 'google'
            };

            localStorage.setItem(AUTH_STORAGE_KEY, JSON.stringify(sessionData));

            // Show main app
            showMainApp();

            // Set user context and load data
            await setUserContext(currentUserId);
            await loadDispositions();
            updateCounts();

            showMessage(`Welcome! You are now logged in with Google as ${user.email}`, 'success');
          }
        } catch (error) {
          console.error('OAuth callback error:', error);
        }
      }

      // Listen for auth state changes
      supabase.auth.onAuthStateChange(async (event, session) => {
        console.log('Auth state changed:', event, session);

        if (event === 'SIGNED_IN' && session) {
          const user = session.user;
          console.log('User signed in:', user);

          // Set user data
          currentUser = user.email;
          currentUserId = user.id;
          isAuthenticated = true;

          // Create session data
          const sessionData = {
            user: user.email,
            userId: user.id,
            loginTime: new Date().getTime(),
            expiresAt: new Date().getTime() + (24 * 60 * 60 * 1000),
            provider: 'google'
          };

          localStorage.setItem(AUTH_STORAGE_KEY, JSON.stringify(sessionData));

          // Show main app
          showMainApp();

          // Set user context and load data
          await setUserContext(currentUserId);
          await loadDispositions();
          updateCounts();

          showMessage(`Welcome! You are now logged in with Google as ${user.email}`, 'success');
        } else if (event === 'SIGNED_OUT') {
          console.log('User signed out');
          // Clear user data without showing confirmation popup
          localStorage.removeItem(AUTH_STORAGE_KEY);
          currentUser = null;
          showLogin();
        }
      });

      // Load initial data and initialize UI
      (async () => {
        // Show loading spinner initially
        showLoadingSpinner();

        // Check for OAuth callback first
        await handleOAuthCallback();

        // Check authentication
        await checkAuthentication();

        // If not authenticated, just initialize empty state
        if (!isAuthenticated) {
          data.length = 0;
          dispositions = {};
        }

        renderCards();
        updateCounts();
      })();

      // Initialize mapping modal
      if (!document.getElementById('mappingModal')) {
        document.body.insertAdjacentHTML('beforeend', mappingModalHtml);
      }


      function exportData() {
        if (!requireAuth()) return;
        if (data.length === 0) {
          alert('‚ùå No data to export!');
          return;
        }

        const headers = [
          'Lead ID',
          'Phone No',
          'Name',
          'Expiry Date',
          'Customer Details',
          'Utilities'
        ];

        const exportRows = data.map(item => {
          if (!item.leadId) item.leadId = getOrCreateLeadId(item);
          const disp = getDisposition(item.leadId);
          const callCount = (disp.history || []).length;

          const dispositionLog = (disp.history || []).map((h, idx) => {
            const timestamp = new Date(h.timestamp);
            const dateStr = timestamp.toLocaleDateString('en-IN', {
              day: '2-digit',
              month: 'short',
              year: 'numeric'
            });
            const timeStr = timestamp.toLocaleTimeString('en-IN', {
              hour: '2-digit',
              minute: '2-digit',
              hour12: true
            });

            const status = (h.status || 'pending').replace(/_/g, ' ').toUpperCase();
            const notes = h.notes ? h.notes.trim() : 'No notes';

            let logEntry = `Call ${idx + 1}: [${dateStr} at ${timeStr}] Status: ${status} | Notes: ${notes}`;

            if (h.callback) {
              const cbTime = new Date(h.callback);
              const cbDateStr = cbTime.toLocaleDateString('en-IN', {
                day: '2-digit',
                month: 'short',
                year: 'numeric'
              });
              const cbTimeStr = cbTime.toLocaleTimeString('en-IN', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: true
              });
              logEntry += ` | Callback Scheduled: ${cbDateStr} at ${cbTimeStr}`;
            }

            return logEntry;
          }).join(' || ');

          const currentStatus = (disp.status || 'pending').replace(/_/g, ' ').toUpperCase();

          let callbackInfo = 'Not Scheduled';
          if (disp.callback) {
            const cbTime = new Date(disp.callback);
            callbackInfo = cbTime.toLocaleDateString('en-IN', {
              day: '2-digit',
              month: 'short',
              year: 'numeric'
            }) + ' at ' + cbTime.toLocaleTimeString('en-IN', {
              hour: '2-digit',
              minute: '2-digit',
              hour12: true
            });
          }

          let lastUpdated = 'Never';
          if (disp.lastUpdated) {
            const luTime = new Date(disp.lastUpdated);
            lastUpdated = luTime.toLocaleDateString('en-IN', {
              day: '2-digit',
              month: 'short',
              year: 'numeric'
            }) + ' at ' + luTime.toLocaleTimeString('en-IN', {
              hour: '2-digit',
              minute: '2-digit',
              hour12: true
            });
          }

          // Create Customer Details string
          const customerDetails = [];

          // Add plan information
          if (item.plan) customerDetails.push(`Plan - ${item.plan.split(' - SI:')[0] || item.plan}`);
          if (item.sumInsured) customerDetails.push(`Sum Insured - ${item.sumInsured}`);
          if (item.amount) customerDetails.push(`Total Premium - ‚Çπ${item.amount.toLocaleString("en-IN")}`);
          if (item.addonCost && item.addonCost > 0) customerDetails.push(`Addon Cost - ‚Çπ${item.addonCost.toLocaleString("en-IN")}`);
          if (item.company) customerDetails.push(`Company - ${item.company}`);
          if (item.dob) customerDetails.push(`Age/DOB - ${item.dob}`);

          // Add custom fields
          if (item.mainCustomFields) {
            Object.entries(item.mainCustomFields).forEach(([key, value]) => {
              if (value) {
                const displayKey = key.endsWith('_checked') ? key.replace('_checked', '') : key;
                customerDetails.push(`${displayKey} - ${value}`);
              }
            });
          }

          // Add customer details from the item
          if (item.customerDetails) {
            // Prefer newline-separated details (newer format). Fall back to pipe-separated for legacy data.
            const details = item.customerDetails.includes('\n') ? item.customerDetails.split('\n') : item.customerDetails.split(' | ');
            details.forEach(detail => {
              if (detail && detail.trim()) customerDetails.push(detail.trim());
            });
          }

          const customerDetailsStr = customerDetails.join('\n');

          // Create Utilities string
          const utilities = [];
          utilities.push(`Current Status - ${currentStatus}`);
          if (disp.notes) utilities.push(`Latest Notes - ${disp.notes}`);
          utilities.push(`Callback - ${callbackInfo}`);
          utilities.push(`Last Updated - ${lastUpdated}`);
          utilities.push(`Total Calls - ${callCount}`);
          utilities.push(`Disposition Log - ${dispositionLog || 'No interaction history available'}`);

          const utilitiesStr = utilities.join('\n');

          return [
            item.leadId,
            item.phone,
            item.name,
            item.date,
            customerDetailsStr,
            utilitiesStr
          ];
        });

        const csvRows = [headers, ...exportRows].map(row => {
          return row.map(cell => {
            const str = String(cell).replace(/"/g, '""');
            return `"${str}"`;
          }).join(',');
        }).join('\n');

        const blob = new Blob(['\uFEFF' + csvRows], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');

        const timestamp = new Date();
        const dateStr = timestamp.toISOString().split('T')[0];
        const fileName = `Insurance_CRM_Export_${dateStr}.csv`;

        link.setAttribute('href', url);
        link.setAttribute('download', fileName);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        const totalCalls = data.reduce((sum, item) => {
          const disp = getDisposition(item.leadId);
          return sum + (disp.history || []).length;
        }, 0);

        alert(`‚úÖ Export Successful!\n\nüìä Summary:\n‚Ä¢ Total Leads: ${data.length}\n‚Ä¢ Total Interactions: ${totalCalls}\n‚Ä¢ File: ${fileName}\n\n‚ú® Export includes complete disposition logs with date, time, status, notes, and callbacks for each customer interaction.`);
      }

      async function handleBackupRestore(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (!confirm('‚ö†Ô∏è Restore from backup?\n\nThis will replace ALL current data with the backup data.\n\nAre you sure you want to continue?')) {
          event.target.value = '';
          return;
        }

        const reader = new FileReader();
        reader.onload = async function (e) {
          try {
            const text = e.target.result;

            // More robust CSV parsing function
            function parseCSV(csvText) {
              const rows = [];
              let currentRow = [];
              let currentField = '';
              let inQuotes = false;
              let i = 0;

              while (i < csvText.length) {
                const char = csvText[i];
                const nextChar = csvText[i + 1];

                if (char === '"') {
                  if (inQuotes && nextChar === '"') {
                    // Escaped quote
                    currentField += '"';
                    i += 2;
                    continue;
                  } else {
                    // Toggle quote state
                    inQuotes = !inQuotes;
                  }
                } else if (char === ',' && !inQuotes) {
                  // End of field
                  currentRow.push(currentField.trim());
                  currentField = '';
                } else if ((char === '\n' || char === '\r') && !inQuotes) {
                  // End of row
                  currentRow.push(currentField.trim());
                  if (currentRow.length > 0 && currentRow.some(field => field.length > 0)) {
                    rows.push(currentRow);
                  }
                  currentRow = [];
                  currentField = '';
                  // Skip \r\n combination
                  if (char === '\r' && nextChar === '\n') {
                    i++;
                  }
                } else {
                  // Regular character
                  currentField += char;
                }

                i++;
              }

              // Add the last field and row
              currentRow.push(currentField.trim());
              if (currentRow.length > 0 && currentRow.some(field => field.length > 0)) {
                rows.push(currentRow);
              }

              return rows;
            }

            const rows = parseCSV(text);

            if (rows.length < 2) {
              alert('‚ùå Invalid backup file format\n\nFile must have at least 2 rows (headers + data)');
              event.target.value = '';
              return;
            }

            const headers = rows[0].map(h => h.toLowerCase().trim());

            // Debug information
            console.log('Backup file headers found:', headers);
            console.log('Total rows in file:', rows.length);

            // Check for new format first, then fallback to old format
            const newFormatHeaders = ['lead id', 'phone no', 'name', 'expiry date', 'customer details', 'utilities'];
            const oldFormatHeaders = ['lead id', 'customer name', 'phone number', 'plan name', 'renewal date', 'sum insured', 'total premium', 'addon cost', 'age/dob', 'current status', 'latest notes', 'callback date/time', 'last updated', 'total calls', 'complete disposition log'];

            const foundNewHeaders = newFormatHeaders.filter(rh => headers.some(h => h === rh));
            const foundOldHeaders = oldFormatHeaders.filter(rh => headers.some(h => h === rh));

            console.log('Required headers (new format):', newFormatHeaders);
            console.log('Required headers (old format):', oldFormatHeaders);
            console.log('Found headers (new format):', foundNewHeaders);
            console.log('Found headers (old format):', foundOldHeaders);

            let isNewFormat = false;
            let isOldFormat = false;

            if (foundNewHeaders.length >= 4) { // At least Lead ID, Phone, Name, Expiry Date
              isNewFormat = true;
            } else if (foundOldHeaders.length >= 10) { // At least most old format headers
              isOldFormat = true;
            }

            if (!isNewFormat && !isOldFormat) {
              const missingNewHeaders = newFormatHeaders.filter(rh => !headers.some(h => h === rh));
              const missingOldHeaders = oldFormatHeaders.filter(rh => !headers.some(h => h === rh));

              alert(`‚ùå Invalid backup file format.\n\nMissing headers for new format: ${missingNewHeaders.join(', ')}\nMissing headers for old format: ${missingOldHeaders.join(', ')}\n\nFound headers: ${headers.join(', ')}\n\nPlease upload a file exported from this system.`);
              event.target.value = '';
              return;
            }

            console.log(`Using ${isNewFormat ? 'new' : 'old'} backup format`);

            const restoredData = [];
            const restoredDispositions = {};
            let successCount = 0;
            let errorCount = 0;

            console.log('Starting to process data rows...');
            let processedRows = 0;
            let skippedRows = 0;

            for (let i = 1; i < rows.length; i++) {
              const row = rows[i];

              // Skip empty rows
              if (!row || row.length === 0 || (row.length === 1 && row[0].trim() === '')) {
                skippedRows++;
                continue;
              }

              processedRows++;

              // Log every 1000th row to avoid console spam
              if (processedRows % 1000 === 0) {
                console.log(`Processed ${processedRows} rows so far...`);
              }

              // More flexible column validation
              const minColumns = isNewFormat ? 4 : 10; // Minimum required columns
              if (row.length < minColumns) {
                console.warn(`Row ${i} has insufficient columns (${row.length}, need ${minColumns}), skipping`);
                errorCount++;
                continue;
              }

              try {
                const getCell = (colName) => {
                  const idx = headers.indexOf(colName.toLowerCase());
                  return idx >= 0 && idx < row.length ? row[idx] : '';
                };

                let leadId, phone, name, expiryDate, customerDetailsStr, utilitiesStr;

                if (isNewFormat) {
                  // New format processing
                  leadId = getCell('lead id');
                  phone = getCell('phone no').replace(/[^0-9]/g, '');
                  name = getCell('name');
                  expiryDate = getCell('expiry date');
                  customerDetailsStr = getCell('customer details');
                  utilitiesStr = getCell('utilities');
                } else {
                  // Old format processing
                  leadId = getCell('lead id');
                  phone = getCell('phone number').replace(/[^0-9]/g, '');
                  name = getCell('customer name');
                  expiryDate = getCell('renewal date');

                  // Reconstruct customer details from old format
                  const planName = getCell('plan name');
                  const sumInsured = getCell('sum insured');
                  const premium = getCell('total premium');
                  const addonCost = getCell('addon cost');
                  const ageDob = getCell('age/dob');

                  customerDetailsStr = `Plan - ${planName}\nSum Insured - ${sumInsured}\nTotal Premium - ${premium}\nAddon Cost - ${addonCost}\nAge/DOB - ${ageDob}`;

                  // Reconstruct utilities from old format
                  const currentStatus = getCell('current status');
                  const notes = getCell('latest notes');
                  const callbackStr = getCell('callback date/time');
                  const lastUpdatedStr = getCell('last updated');
                  const callCount = getCell('total calls');
                  const dispositionLog = getCell('complete disposition log');

                  utilitiesStr = `Current Status - ${currentStatus}\nLatest Notes - ${notes}\nCallback - ${callbackStr}\nLast Updated - ${lastUpdatedStr}\nTotal Calls - ${callCount}\nDisposition Log - ${dispositionLog}`;
                }

                if (!leadId || !name || !phone) {
                  console.warn(`Row ${i}: Missing required fields - LeadId: ${leadId}, Name: ${name}, Phone: ${phone}`);
                  errorCount++;
                  continue;
                }

                console.log(`Row ${i}: Successfully parsed - LeadId: ${leadId}, Name: ${name}, Phone: ${phone}`);

                // Parse customer details
                let planName = '';
                let sumInsured = '';
                let premium = 0;
                let addonCost = 0;
                let company = '';
                let dob = '';
                let mainCustomFields = {};
                let customerDetails = '';

                if (customerDetailsStr) {
                  const details = customerDetailsStr.split('\n');
                  details.forEach(detail => {
                    if (detail.includes('Plan - ')) {
                      planName = detail.replace('Plan - ', '').trim();
                    } else if (detail.includes('Sum Insured - ')) {
                      sumInsured = detail.replace('Sum Insured - ', '').trim();
                    } else if (detail.includes('Total Premium - ‚Çπ')) {
                      premium = parseInt(detail.replace('Total Premium - ‚Çπ', '').replace(/,/g, '')) || 0;
                    } else if (detail.includes('Addon Cost - ‚Çπ')) {
                      addonCost = parseInt(detail.replace('Addon Cost - ‚Çπ', '').replace(/,/g, '')) || 0;
                    } else if (detail.includes('Company - ')) {
                      company = detail.replace('Company - ', '').trim();
                    } else if (detail.includes('Age/DOB - ')) {
                      dob = detail.replace('Age/DOB - ', '').trim();
                    } else if (detail.includes(' - ')) {
                      // Custom fields with - separator
                      const parts = detail.split(' - ');
                      if (parts.length >= 2) {
                        const key = parts[0].trim();
                        const value = parts.slice(1).join(' - ').trim();
                        // Check if this field was originally checked (has _check suffix in original data)
                        // We'll add _check suffix back to maintain the original state
                        const originalKey = key; // Keep original key for now
                        mainCustomFields[originalKey] = value;
                      }
                    } else if (detail.includes(': ')) {
                      // Custom fields with : separator (from unchecked fields)
                      const parts = detail.split(': ');
                      if (parts.length >= 2) {
                        let key = parts[0].trim();
                        const value = parts.slice(1).join(': ').trim();

                        // Handle _unchecked marker
                        if (key.endsWith('_unchecked')) {
                          key = key.replace('_unchecked', '');
                          // Don't add to mainCustomFields, keep in customerDetails
                        } else {
                          mainCustomFields[key] = value;
                        }
                      }
                    }
                  });
                }

                // Parse utilities
                let currentStatus = 'pending';
                let notes = '';
                let callbackStr = 'Not Scheduled';
                let lastUpdatedStr = 'Never';
                let dispositionLog = '';

                if (utilitiesStr) {
                  const utilities = utilitiesStr.split('\n');
                  utilities.forEach(util => {
                    if (util.includes('Current Status - ')) {
                      currentStatus = util.replace('Current Status - ', '').trim().toLowerCase().replace(/ /g, '_');
                    } else if (util.includes('Latest Notes - ')) {
                      notes = util.replace('Latest Notes - ', '').trim();
                    } else if (util.includes('Callback - ')) {
                      callbackStr = util.replace('Callback - ', '').trim();
                    } else if (util.includes('Last Updated - ')) {
                      lastUpdatedStr = util.replace('Last Updated - ', '').trim();
                    } else if (util.includes('Disposition Log - ')) {
                      dispositionLog = util.replace('Disposition Log - ', '').trim();
                    }
                  });
                }

                // Restore customer data
                const item = {
                  sno: restoredData.length + 1,
                  leadId: leadId,
                  name: name,
                  phone: phone,
                  date: expiryDate,
                  plan: planName ? `${planName} - SI: ${sumInsured}` : 'Care Supreme',
                  dob: dob,
                  amount: premium,
                  sumInsured: sumInsured,
                  addonCost: addonCost,
                  company: company,
                  mainCustomFields: mainCustomFields,
                  customerDetails: customerDetails
                };

                restoredData.push(item);

                // Restore disposition data
                const disposition = {
                  status: currentStatus === 'pending' ? 'pending' : currentStatus,
                  notes: notes && notes !== 'No notes added' && notes !== 'No notes' ? notes : '',
                  callback: null,
                  lastUpdated: null,
                  history: []
                };

                // Parse callback
                if (callbackStr && callbackStr !== 'Not Scheduled') {
                  try {
                    const cbParts = callbackStr.split(' at ');
                    if (cbParts.length === 2) {
                      const cbDate = new Date(cbParts[0] + ' ' + cbParts[1]);
                      if (!isNaN(cbDate.getTime())) {
                        disposition.callback = cbDate.toISOString();
                      }
                    }
                  } catch (e) {
                    console.warn('Could not parse callback date:', e);
                  }
                }

                // Parse last updated
                if (lastUpdatedStr && lastUpdatedStr !== 'Never') {
                  try {
                    const luParts = lastUpdatedStr.split(' at ');
                    if (luParts.length === 2) {
                      const luDate = new Date(luParts[0] + ' ' + luParts[1]);
                      if (!isNaN(luDate.getTime())) {
                        disposition.lastUpdated = luDate.toISOString();
                      }
                    }
                  } catch (e) {
                    console.warn('Could not parse last updated:', e);
                  }
                }

                // Parse disposition history
                if (dispositionLog && dispositionLog !== 'No interaction history available') {
                  const logEntries = dispositionLog.split(' || ');

                  logEntries.forEach(entry => {
                    try {
                      // Format: Call 1: [05 Oct 2025 at 02:30 PM] Status: INTERESTED | Notes: text | Callback Scheduled: ...
                      const dateTimeMatch = entry.match(/\[(.*?)\]/);
                      const statusMatch = entry.match(/Status:\s*([^|]+)/);
                      const notesMatch = entry.match(/Notes:\s*([^|]+)/);
                      const callbackMatch = entry.match(/Callback Scheduled:\s*(.+)$/);

                      if (dateTimeMatch && statusMatch) {
                        // Parse timestamp
                        let timestamp;
                        try {
                          const dtStr = dateTimeMatch[1].trim();
                          // Convert "05 Oct 2025 at 02:30 PM" to Date
                          const parts = dtStr.split(' at ');
                          if (parts.length === 2) {
                            const dateStr = parts[0];
                            const timeStr = parts[1];
                            timestamp = new Date(dateStr + ' ' + timeStr);
                          } else {
                            timestamp = new Date(dtStr);
                          }
                        } catch (e) {
                          timestamp = new Date();
                        }

                        // Parse status
                        const status = statusMatch[1].trim().toLowerCase().replace(/ /g, '_');

                        // Parse notes
                        let histNotes = '';
                        if (notesMatch) {
                          histNotes = notesMatch[1].trim();
                          if (histNotes === 'No notes') {
                            histNotes = '';
                          }
                        }

                        // Create history entry
                        const histEntry = {
                          status: status,
                          notes: histNotes,
                          timestamp: timestamp.toISOString(),
                          callback: null
                        };

                        // Parse callback if exists
                        if (callbackMatch) {
                          try {
                            const cbStr = callbackMatch[1].trim();
                            const cbParts = cbStr.split(' at ');
                            if (cbParts.length === 2) {
                              const cbDate = new Date(cbParts[0] + ' ' + cbParts[1]);
                              if (!isNaN(cbDate.getTime())) {
                                histEntry.callback = cbDate.toISOString();
                              }
                            }
                          } catch (e) {
                            console.warn('Could not parse callback in history:', e);
                          }
                        }

                        disposition.history.push(histEntry);
                      }
                    } catch (e) {
                      console.warn('Error parsing history entry:', entry, e);
                    }
                  });
                }

                restoredDispositions[leadId] = disposition;
                successCount++;

              } catch (err) {
                errorCount++;
                console.warn(`Error processing row ${i}:`, err);
              }
            }

            console.log(`Processing complete - Success: ${successCount}, Errors: ${errorCount}, Skipped: ${skippedRows}`);

            if (successCount === 0) {
              let errorMsg = '‚ùå No valid data found in backup file\n\n';
              errorMsg += `üìä Processing Summary:\n`;
              errorMsg += `‚Ä¢ Total rows in file: ${rows.length - 1}\n`;
              errorMsg += `‚Ä¢ Rows processed: ${processedRows}\n`;
              errorMsg += `‚Ä¢ Rows skipped (empty): ${skippedRows}\n`;
              errorMsg += `‚Ä¢ Successful imports: ${successCount}\n`;
              errorMsg += `‚Ä¢ Errors encountered: ${errorCount}\n\n`;
              errorMsg += `üîç Common issues:\n`;
              errorMsg += `‚Ä¢ Check if file has correct headers\n`;
              errorMsg += `‚Ä¢ Ensure Lead ID, Name, and Phone are present\n`;
              errorMsg += `‚Ä¢ Verify file was exported from this system\n`;
              errorMsg += `‚Ä¢ Check for corrupted CSV data or encoding issues\n\n`;
              errorMsg += `üí° Check browser console for detailed error information.`;

              alert(errorMsg);
              event.target.value = '';
              return;
            }

            // Apply restored data
            data.length = 0;
            data.push(...restoredData);

            dispositions = restoredDispositions;

            // Save to Supabase
            await saveCustomerData(data);
            await saveDispositionsToSupabase(dispositions);

            // Refresh UI
            renderCards();
            updateCounts();

            alert(`‚úÖ Backup Restored Successfully!\n\nüìä Summary:\n‚Ä¢ Leads Restored: ${successCount}\n‚Ä¢ Total Interactions: ${Object.values(dispositions).reduce((sum, d) => sum + (d.history || []).length, 0)}\n‚Ä¢ Rows Processed: ${processedRows}\n‚Ä¢ Rows Skipped: ${skippedRows}\n${errorCount > 0 ? `\n‚ö†Ô∏è ${errorCount} rows had errors and were skipped.` : ''}\n\n‚ú® All customer data, dispositions, notes, callbacks, and complete history have been restored.`);

          } catch (error) {
            alert('‚ùå Error reading backup file: ' + error.message);
            console.error('Backup restore error:', error);
          }
        };

        reader.readAsText(file);
        event.target.value = '';
      }

      // Initialize authentication and app
      checkAuthentication();
    </script>
  </div> <!-- End of mainApp -->
</body>

</html>